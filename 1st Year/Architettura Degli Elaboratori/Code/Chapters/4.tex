\section{Modello di Von Neumann e Unità funzionali del calcolatore}
Ebbene, sei ufficialmente sopravvissuto/a a metà del corso; rinunciare ora sarebbe disdicevole, non trovi? Minchiate a parte, parliamo del modello base di letteralmente ogni architettura di calcolatori: il Modello di Von Neumann.\par\quad
Si tratta di un'architettura costituita da tre componenti interconnesse da un dispositivo chiamato \textbf{BUS}\footnote{Flusso di bits che rende possibile la comunicazione fra le varie componenti}:
\begin{itemize}
    \item Processore; la Central Processing Unit, esegue le istruzioni.
    \item Memoria; composta da registri, salva le istruzioni e i dati.
    \item Dispositivi di I/O; periferiche come tastiere o altoparlanti.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{Images/VonNeumann.png}
    \caption{Modello Di Von Neumann}
    \label{fig:enter-label}
\end{figure}

Un calcolatore è costituito dalle seguenti parti principali, indipendenti l'una dall'altra:
\begin{itemize}
    \item Unità di ingresso ed uscita (I/O).
    \item Arithmetic Logic Unit (ALU).
    \item Control Unit, che compone processore e memoria.
\end{itemize}
Queste componenti lavorano sotto la supervisione ed il controllo della \textbf{Control Unit}; l'\textbf{Input Unit} riceve informazioni in forma codificata da operatori o periferiche come tastiere e vengono utilizzate dalla \textbf{ALU} per effettuare operazioni, eventualmente salvando in \textbf{memoria} i risultati.
Quanto eseguito viene infine inviato all'\textbf{Output Unit} che ritornerà quanto eseguito.\par\quad
Le informazioni manipolate sono categorizzate in \textbf{istruzioni} e \textbf{dati}. Le prime sono i comandi dati alla macchina direttamente interpretabili da essa, mentre i secondi sono le informazioni che vengono manipolate.\par\quad
Una lista di istruzioni compone il \textbf{programma}, il quale, se in esecuzione, si troverà \textit{sempre} in memoria, a meno che non venga dato un comando di interruzione.\par\quad
Il nostro ambiente di lavoro sarà la CPU Intel 80x86, la quale ha la particolarità di utilizzare lo stesso linguaggio del microprocessore: \textbf{Assembly}. L'insieme che compone le istruzioni scritte in tale lingua leggibili dal microprocessore si dice \textbf{Instruction Set Architecture}, (ISA), ed è letto da un \textbf{assemblatore}, il quale provvederà a tradurlo in codice oggetto.\par
Ma come è fatta una CPU? Andiamo a vedere nello specifico ogni componente. Consiglio di studiare attentamente la figura 4.2, così almeno ti fai un'idea.\newline

\begin{figure}[h]
    \centering
    \includegraphics[width=0.85\linewidth]{Images/ArchCPU.drawio.png}
    \caption{Architettura della CPU}
    \label{fig:enter-label}
\end{figure}

\textbf{- Componenti generali:}
\begin{itemize}
    \item \textit{Bus Dati}; Consente di trasportare i dati fra le varie componenti.
    \item \textit{Bus Indirizzi}; Comunica gli indirizzi di memoria delle informazioni.
    \item \textit{Bus di Controllo}; Invia i segnali di controllo fra le varie componenti.
    \item \textit{Memory Address Register}; Tiene in memoria e fornisce gli indirizzi dei dati da manipolare.
    \item \textit{Memory Data Register}; Salva temporaneamente i dati da o per la CPU
    \item \textit{Registri}; Salvano le informazioni elaborate.
    \item \textit{ALU}; Esegue operazioni logico-matematiche con i vari dati.
\end{itemize}
\textbf{- Componenti della Control Unit:}
\begin{itemize}
    \item \textit{Instruction Register}; Contiene le istruzioni da eseguire.
    \item \textit{Program Counter}; Contiene gli indirizzi delle operazioni da eseguire.
    \item \textit{Program Status Word}; Insieme di flags che, in stretta collaborazione con la ALU, indicano lo stato dei diversi risultati di operazioni matematiche. Si modifica ad ogni singola operazione.
\end{itemize}
Tutto molto bello, ma come funziona? Ci è possibile descrivere tale processo mediante una FSM a tre stati, chiamati \textbf{Fetch}, \textbf{Decode} ed \textbf{Execution}.
\begin{enumerate}
    \item \textit{Fetch}; Fase di ricezione delle informazioni. Ottiene il necessario dall'MDR e lo passa all'IR mediante il Bus Dati. Il Program Counter aumenterà di 1 ad ogni istruzione.
    \item \textit{Decode}; Fase di decodifica delle istruzioni. Mediante l'ISA dell'architettura, indirizza opportunamente i dati per farli elaborare.
    \item \textit{Execution}; Esecuzione delle istruzioni decodificate.\newline
\end{enumerate}
\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{Images/CPUFSM.drawio.png}
    \caption{Macchina a stati della CPU}
    \label{fig:enter-label}
\end{figure}
Un'ultima cosa di cui tener conto è la struttura in bit delle istruzioni dell'ISA, poiché ricorda che tutto ciò che legge la macchina sono segnali di assenza/presenza. Queste sono divise in tre parti:
\begin{itemize}
    \item \textit{OPcode}; Il codice operazione. Ci fa capire quante istruzioni possono essere registrate, ma soprattutto quale sta venendo effettuata.
    \item \textit{Source Address}; L'indirizzo dal quale ottenere le informazioni.
    \item \textit{Destination Address}; L'indirizzo nel quale verranno salvate le informazioni.\newline
\end{itemize}

Abbiamo parlato molto di indirizzi finora e credo basti questo per capire quanto sia fondamentale questo concetto. Infatti per lavorare sui dati è necessario conoscere il loro indirizzo, ed è per questo che abbiamo ben \textit{cinque} metodi di indirizzamento diversi:
\begin{itemize}
    \item \textit{Indirizzamento a registro} - [MOVL \%EAX, \%EBX]\par
    Sposta il contenuto del registro EAX in EBX.
    \item \textit{Indirizzamento immediato} - [MOVL \$8, \%ECX]\par
    Sposta il valore 8 nel registro ECX.
    \item \textit{Indirizzamento assoluto} - [MOVL DATO, \%EDX]\par
    Non dissimile dalla dichiarazione di una variabile in C, richiede una lettura in memoria.
    \item \textit{Indirizzamento indiretto a registro} - [MOVL (\%EAX), \%EBX]\par
    Interpreta il contenuto di EAX come un indirizzo e viene messo in EBX.
    \item \textit{Indirizzamento indiretto a registro con spezzamento} - [MOVL \$8(\%EBX), \%ECX]\par
    Somma il valore 8 al contenuto di EBX inteso come indirizzo, per poi salvarlo in ECX.  
\end{itemize}

Questa parte del programma è fondamentale, perché se manca la comprensione del funzionamento della CPU, non sarà possibile comprendere appieno tutto ciò che concernerà la suddetta componente; ovvero tutto. La CPU fa tutto.

%

\section{CPU - Central Processing Unit}
Vediamo ora i due tipi di CPU che potremmo incontrare nel corso del nostro lavoro: le \textbf{CPU cablate} e le \textbf{CPU microprogrammate}. La loro differenza principale è che la prima si tratta di un circuito sequenziale generante segnali di controllo, mentre la seconda è un'unità contenente microistruzioni nella memoria di controllo per generare i relativi segnali... di controllo. Vediamole quindi nel dettaglio.

\subsection{CPU Cablata}
Il circuito della CPU cablata è creato mediante l'utilizzo di componenti elettroniche; ciò significa che nel caso in cui l'ISA dovesse essere modificato, lo stesso destino colpirà il cablaggio, rendendo questo modello \textit{molto poco} flessibile ai cambiamenti. Tuttavia, il loro vantaggio è la velocità di elaborazione nel loro specifico compito e capirai di conseguenza che per i sistemi embedded sono perfette.\par\quad
Le CPU cablate sono dotate di un \textbf{Bus Interno} con la capacità di trasportare dati da massimo 4Byte. Notare inoltre la presenza del \textbf{Tri-State Buffer}\footnote{Nella figura 4.4, il cerchio con una croce al suo interno}, il cui scopo è interrompere il flusso del segnale quando il Program Counter segna 0.\par\quad
Il registro Y sottostante ad esso è necessario per selezionare l'operazione della ALU, ricevente i dati da elaborare nello stesso momento. Questi ultimi saranno salvati nel registro Z e mediante il Bus interno, spediti nel registro occorrente.\par\quad
Il compito delle altre componenti è invariato da quello già trattato nello scorso paragrafo e non voglio in alcun modo ripetermi.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{Images/CPU cablata.drawio.png}
    \caption{Modello di CPU cablata}
    \label{fig:enter-label}
\end{figure}

\subsection{CPU Microprogrammata}
Questa architettura non è rinomata per la sua velocità, tuttavia ha la capacità di svolgere compiti diversi. Come si suol dire; conoscitore di molti, maestro di nessuno.
Il punto di forza della CPU microprogrammata è la sua \textit{semplicità}, che rende facile non solo la sua progettazione, ma anche l'apporto di eventuali modifiche.\par\quad
Il modello utilizza una \textit{parola di controllo}, riferita ad una parola binaria. Si tratta dei classici insiemi di bits e vengono utilizzate per specificare le \textbf{micro-operazioni}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\linewidth]{Images/CPU microprogrammata.png}
    \caption{Modello di CPU microprogrammata}
    \label{fig:enter-label}
\end{figure}

\subsection{Microistruzioni CPU}
Tempo di arrivare alla pratica delle micro-istruzioni. Gli esercizi consistono nella scrittura di ogni singola componente attiva assieme al compito che viene eseguito in funzione di una determinata architettura. In questo caso useremo la CPU cablata.\par\quad
Le istruzioni sono lette sequenzialmente, ma ogni riga si esegue nello stesso ciclo di clock. Ciò significa che non importa l'ordine delle operazioni di una riga, ma bisogna stare attenti al loro insieme in tale posizione. Faccio davvero prima a farti vedere con ben quattro esempi.\newline

\textbf{1. Indirizzamento a registro}: MOVL \%EAX, \%EBX
\begin{verbatim}
    PC-in, MAR-in, READ, ADD, Z-in
    WMFC, Z-out, PC-in
    MDR-out, IR-in
    EAX-out, EBX-in, END 
\end{verbatim}
Abbiamo scritto in totale quattro righe, dove le prime tre sono universali e fanno parte della fase di \textit{Fetch} (per brevità indicherò queste linee con la parola "FETCH"), mentre l'ultima prevede la fusione di \textit{Decode} ed \textit{Execution} nello stesso ciclo di clock. Una riga corrisponde ad un clock tick, di conseguenza avremo CPI = 4.\par In ordine, le istruzioni significano quanto segue:
\begin{enumerate}
    \item PC incrementato di 1, MAR riceve i dati, lettura dei dati, istruzione "+" della ALU e salva il risultato nel registro Z.
    \item Aspetta la fine della funzione in memoria\footnote{WMFC, Wait Memory Function Complete è necessario a bloccare il clock della CPU nel caso servisse più tempo per effettuare un'operazione ed ottenerne i dati.}, fai uscire i dati da Z (per poterli trasferire col bus interno) e PC incrementato di 1.
    \item Invia i dati dall'MDR all'IR.
    \item Invia il contenuto di EAX in EBX e termina il processo.
\end{enumerate}

\textbf{2. Indirizzamento indiretto a registro}: MOVL (\%EAX), \%EBX
\begin{verbatim}
    "FETCH"
    EAX-out, MAR-in, READ
    WMFC
    MDR-out, EBX-in, END
\end{verbatim}
Le due righe dopo FETCH appartengono alla fase di \textit{Decode}, necessaria perché stiamo considerando il contenuto del primo registro come un indirizzo ed è quindi richiesto l'intervento del MAR per far sì che la macchina trovi il dato. Capirai che l'ultima riga rappresenta l'esecuzione. In tutto abbiamo CPI = 6.\par
Il significato di ogni singola istruzione dopo il fetch è:
\begin{enumerate}
    \item Invia il contenuto di EAX al MAR ed effettua una lettura del dato in tale indirizzo.
    \item Aspetta che finisca di leggere.
    \item Invia quanto trovato dall'MDR al registro EBX e termina il processo.
\end{enumerate}

\textbf{3. Indirizzamento immediato} MOVL \$4, \%ECX
\begin{verbatim}
   "FETCH"
   OFFSET_IR-out, Y-in
   ECX-out, SELECT_Y, ADD, Z-in
   Z-out, ECX-in, END
\end{verbatim}
Qui non serve alcuna decodifica perché abbiamo un valore specifico, di conseguenza \textit{Execution} viene subito dopo "FETCH". Spero tu abbia capito come contare i CPI perché non mi ripeterò più da ora.\par
Le istruzioni significano:
\begin{enumerate}
    \item Prendi il valore dell'offset dell'IR ed inseriscilo nel registro Y.
    \item Invia il contenuto di ECX alla ALU e usa come secondo operando il contenuto del registro Y. Effettuane la somma ed inserisci il risultato nel registro Z.
    \item Invia il contenuto di Z al registro ECX e termina il processo.
\end{enumerate}
\textbf{4. Istruzione di salto (check se 0) alla fine}: JZ END
\begin{verbatim}
    "FETCH"
    if zero == 0 -> END, OFFSET_REG-out, Y-in
    PC-out, SELECT_Y, ADD, Z-in
    Z-out, PC-in, END
\end{verbatim}
Parto dal presupposto che questa istruzione è una carognata. La CPU se potesse ti sputerebbe in un occhio solo per aver scritto st'aborto. Detto questo, nemmeno qua è richiesta una decodifica.\par
Il significato è tale:
\begin{enumerate}
    \item Controllo se la parola "zero" equivale allo "0" e se questa uguaglianza è vera, termina il processo. Per questo controllo, invia l'offset del registro ad Y.
    \item Invia il conteggio di PC alla ALU e sommalo al contenuto di Y, per poi salvare tutto in Z.
    \item Invia il contenuto di Z al PC per spostarlo alla posizione desiderata e termina il processo.
\end{enumerate}
Come dici? È un botto di roba? Ti farà sapere piacere che le microistruzioni compongono \textit{sicuramente} un esercizio dell'esame, quindi richiamo all'attenzione la frase associata al libro per motivarti.

%

\section{Metodi di input/output, segnale interrupt}
I dispositivi di Input ed Output \textbf{I/O}, detti anche \textit{periferiche}, consentono di effettuare uno scambio di dati dalla persona alla macchina e viceversa. Dei classici esempi sono tastiere, mouse ed altoparlanti.\par\quad

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\linewidth]{Images/i_oDevice.drawio.png}
    \caption{Dispositivo di Input/Output}
    \label{fig:enter-label}
\end{figure}

Sono capaci di codificare l'informazione e mandarla al sistema mediante l'utilizzo di due registri da 1B l'uno. Osserviamo le loro componenti:
\begin{itemize}
    \item \textbf{Micro-Controllore}; Piccola CPU dedicata al dispositivo. Supervisiona e controlla qualunque cosa si faccia.
    \item \textbf{Registro Dati}; Dove sono salvate tutte le codifiche della periferica. L'input è ricevuto attivamente e viene tradotto dall'interfaccia.
    \item \textbf{Registro Stato}; Effettua una funzione analoga al PSW ed esattamente come lui, ogni bit ha significato.
    \item \textbf{Interfaccia Analogico-Digitale}; Componente che traduce da segnale analogico a segnale digitale.
\end{itemize}

I dispositivi I/O sono \textbf{Memory Mapped}; ciò significa che \textit{nella macchina intera} esiste un intervallo di indirizzi riservato a loro a cui rispondono i registri Dati e Stato. Nel caso in cui si provasse a far accedere la memoria in quei registri, la CPU si rifiuterebbe. L'unico modo per entrarvi è utilizzare gli accessi da \textit{SuperUser} o \textit{Admin}, dipendentemente dal sistema operativo che si usa.\par\quad
Un esempio di istruzione effettuabile con gli indirizzi delle periferiche è il seguente:
\begin{verbatim}
    CMPL $0, %EAX          #Controlla l'attivazione di Stato
    JE TESTKEY
    MOVL INDDATAKEY, %EBX  #Prende il valore ASCII dall'indirizzo del tasto
    MOVL %EBX, INDC
\end{verbatim}  
Con queste linee di istruzioni stiamo effettuando una \textbf{SuperVisor Call}\footnote{SVC, Chiamata per passare il controllo delle operazioni al sistema operativo}. Ciò apre varie possibilità di personalizzazione, come la modifica degli output dei tasti in una tastiera. Se si vuole invece solo gestire le periferiche, si utilizza la tecnica del \textbf{Polling}\footnote{Verifica ciclica dei dispositivi I/O mediante testing dei bits di bus di ogni periferica, seguita da un'interazione R/W.}, implicando che la periferica abbia una potenza simile se non uguale a quella della CPU. In caso contrario, verrebbero persi dati in corso d'opera.\par\quad
Parliamo ora invece di \textbf{Interrupt}; un segnale asincrono che interrompe il lavoro della CPU, ricordando un neonato che piange ed il genitore che se ne prende cura.\par
\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{Images/Interrupt.drawio.png}
    \caption{Funzionamento dell'Interrupt}
    \label{fig:enter-label}
\end{figure}
Osservando la figura possiamo notare due elementi a noi nuovi:
\begin{itemize}
    \item \textit{Interrupt Request}; Un segnale posto sul Bus di Controllo normalmente posto a 1. Se è richiesto un interrupt, il valore diventa 0.
    \item \textit{Interrupt Acknowledgement}; Segnale che conferma quale dispositivo ha richiesto un interrupt.
\end{itemize}
Mediante il secondo segnale, la CPU controlla sequenzialmente ogni dispositivo per capire quale ha abbassato il flag. Una volta trovato, chiama l'\textit{Interrupt Service Routine} ad esso associato. Il suo compito è salvare le modifiche fatte a PC e PSW per poi interrompere il programma; infine interverrà il microprocessore per scaricare quanto appena salvato e tornare allo stato precedente. Tutto questo processo di controllo è parte integrante del \textbf{Device Driver}\footnote{Programma con lo scopo di ottimizzare e ridurre gli sforzi della CPU legati al funzionamento di una periferica.}.\par\quad
Un'ultima cosa da tenere in conto è che gli interrupt signals \textit{non si sovrappongono}\footnote{Tutte quelle volte che hai continuato a premere ESC o l'icona per chiudere la finestra hai sprecato tempo. In ogni caso era meglio aprire Task Manager.} e sono creati per gestire tempi umani. Se c'è un'alta frequenza di questi segnali è necessario trovare un sistema diverso. Ma tu guarda, è proprio la soluzione esplicitata nel capitolo seguente, che fortuna.

%

\section{Direct Memory Access, BUS e arbitraggio}
Iniziamo dando una visione più vasta del problema; è nostro volere trasportare una grande quantità di dati utilizzando il sistema appena visto con l'interrupt signal. Nel modello di Von Neumann avremo di conseguenza il seguente processo:
\begin{enumerate}
    \item I dispositivi I/O ricevono l'input e lo inviano alla CPU.
    \item Ricevuti i dati, si attiverà l'interrupt e si inizierà a lavorare con quanto ottenuto.
    \item I dati elaborati sono salvati in memoria.
\end{enumerate}
Non è di difficile comprensione il fatto che se l'interrupt signal è gestito in questo modo avremo uno spreco di risorse non indifferente ed è esattamente per questo che è stato ideato il concetto di \textbf{DMA}\footnote{Direct Memory Access - Accesso diretto alla memoria}. La CPU programma un dispositivo I/O, per far sì che questo possa accedere direttamente alla memoria senza passare da essa. Sarà inoltre in grado di eseguire operazioni di lettura e scrittura, grazie al suo micro-controllore e i suoi registri.\par\quad
Il senso di tutto ciò è voler affaticare il dispositivo piuttosto che la CPU con lo scopo di risparmiare energia. Infatti, una volta finito il lavoro della periferica con DMA, il microprocessore della macchina dovrà ricevere un singolo interrupt. Tuttavia, ciò fa sorgere un ulteriore problema: più CPU vogliono accedere allo stesso BUS e se questo avesse luogo, i dati potrebbero venire persi o sfalsati. La soluzione sta in una gestione del BUS tramite un \textbf{arbitro}, il cui ruolo è tipicamente vestito dalla CPU principale. Sarà lei a scegliere chi e quando potrà accedere ed usare il BUS. Lo schema non è dissimile dal lavoro che esegue il singolo interrupt signal.\par
Osserviamo ora nel dettaglio una lista delle componenti ed i segnali nuovi presenti nella figura 4.8.\newline

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\linewidth]{Images/ArbitraggioBUS.png}
    \caption{Arbitraggio BUS}
    \label{fig:enter-label}
\end{figure}

\begin{itemize}
    \item \textit{BUS Busy}; Segnale che indica se il BUS è attualmente utilizzato da una componente.
    \item \textit{BUS Request}; Segnale normalmente posto a valore 0, similmente all'interrupt, è una richiesta fatta alla CPU per poter utilizzare il BUS.
    \item \textit{BUS Grant}; Segnale di concessione di utilizzo BUS una volta terminato il precedente lavoro\footnote{La CPU trasmette questo segnale in ordine fissato, da sinistra a destra. Per ottimizzare i tempi, è intelligente porre per prime le componenti più utilizzate dal sistema}.
\end{itemize}
Prima di andare nel dettaglio è necessario familiarizzare con due termini: \textbf{Master} e \textbf{Slave}, le entità sulle quali si basa il funzionamento del BUS. Il primo è l'iniziatore dell'operazione, mentre il secondo ne risponde. Esistono due protocolli di operazione che renderanno rispettivamente un BUS \textit{sincrono}, dipendente da clock o \textit{asincrono}, da esso indipendente. Negli schemi userò degli esagoni per rendere la scrittura più compatta. Se le linee si incrociano avremo un cambio di valore, mentre se sulla stessa riga v'è una linea sola è sinonimo di \textit{alta impedenza}\footnote{La parte non può agire poiché non riceve segnale}. Vediamo meglio i due protocolli insieme ad un particolare funzionamento.\newline

\textbf{- BUS Sincrono}\par
Le operazioni effettuabili sono le classiche lettura e scrittura.\par
La prima vede il Master nel fronte di salita ricevere il dato per poi farlo leggere, produrre ed inviare al BUS Dati dallo Slave nel fronte di discesa.\par
La seconda invece ha le medesime condizioni iniziali, ma lo Slave agirà prima per scrivere il dato.\newline

\textbf{- BUS dal funzionamento Multiciclo}
Questo utilizzo del BUS sincrono è quello che viene generalmente più utilizzato. Crea un ambiente relativamente solido per effettuare operazioni con la sicurezza di poter gestire ritardi o fallimenti, grazie ad un segnale aggiuntivo detto \textit{Pronto}, che si attiva quando l'operazione è stata ultimata. Sceglieremo i cicli minimi che diranno quale coppia M/S è la migliore.\newline

\textbf{- BUS Asincrono}\par
Qui abbiamo un doppio riscontro detto \textbf{Hand-Shaking} e due segnali MasterReady e SlaveReady. Di per sé non è complesso, ma aiuta molto guardare la figura durante la lettura.\par\quad
Diciamo di voler effettuare una lettura a tempo $i$, del quale importa meno di zero poiché siamo liberi da vincoli di clock. Deve ricevere prima il Master, che attiverà il segnale MasterReady e una volta ottenuti i dati, li invierà allo Slave che rimanderà tutto al capo come precedentemente visto. Finito di leggere, una volta confermato che le operazioni sono state completate tramite l'abbassamento di MasterReady, si potrà chiudere l'operazione, liberare il BUS e prepararsi per un'altra.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.8\linewidth]{Images/BUS_Sincrono.png}
    \caption{Operazioni in un BUS Sincrono}
    \label{fig:enter-label}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\linewidth]{Images/Funz_Multiciclo.png}
    \caption{Funzionamento BUS Multiciclo}
    \label{fig:enter-label}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\linewidth]{Images/BUS_Asincrono.png}
    \caption{Lettura in un BUS Asincrono}
    \label{fig:enter-label}
\end{figure}

Questi concetti sono fondamentali in quanto alla base degli elaboratori contemporanei sta il \textit{Multitasking}, che è reso possibile grazie a quanto visto finora.

%

\section{Stati di un processo}
Se le istruzioni possono appartenere ad un solo processo com'è possibile che io riesca a procrastinare lo studio con ben quattro pagine di Youtube aperte? Questa è una buona domanda. Oltre a richiamarti perché devi studiare ti parlo del \textbf{Time Sharing}, un meccanismo di condivisione del runtime fra le varie operazioni.\par\quad
Fondamentalmente si divide l'intervallo di tempo reale in vari sottointervalli di egual misura, la cui dimensione è 1Quanto, che corrisponde ad 1ms.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\linewidth]{Images/TimeSharing.png}
    \caption{Grafico temporale di Time Sharing}
    \label{fig:enter-label}
\end{figure}

Il funzionamento è il seguente:\par\quad
Comincia il primo processo che ha a disposizione 1Q di tempo per lavorare; quando questo termina, si passa al processo successivo e così via fino al loro termine. Tuttavia, nell'eventualità di una \textit{SVC}\footnote{Supervisor Call, richiamo del sistema operativo.} il processo viene interrotto fino alla comunicazione dell'interrupt. In sostanza, la macchina non sta elaborando più processi allo stesso tempo, bensì uno alla volta ma ad una tale velocità che ciò risulta impercettibile.\par\quad
Tutto questo bel meccanismo è gestito dal \textbf{Kernel} del sistema operativo, il quale vede i progressi di un processo in base allo stato in cui si trovano. Osserviamo i quattro stati della macchina.
\begin{itemize}
    \item \textit{ExecutionSystem}; Dato dalla CPU, è lo stato dove ha libero accesso.
    \item \textit{ExecutionUser}; Dato dalla CPU, qui ha accesso limitato per far agire l'utente in caso di una SVC\footnote{Nell'ISA Intel 80x86 le SVC svolgono anche la funzione di interrupt signals e si indicano con "INT".}.
    \item \textit{Waiting}; Stato dove si spostano i processi non terminati mentre la macchina ne esegue altri.
    \item \textit{Ready}; Stato dove si trovano i processi interrotti ora pronti per essere eseguiti. Si basa sulla regola LIFO\footnote{Last-In, First-Out.}.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\linewidth]{Images/FSM Processo.png}
    \caption{FSM degli stati di un processo}
    \label{fig:enter-label}
\end{figure}

Mentre la CPU conta i cicli di clock dedicati agli interrupt signals, il sistema operativo può intervenire sui processi grazie allo \textbf{Scheduler}, il cui compito è decidere se dare ulteriore tempo ad un processo per interromperlo o terminarlo in base al tempo utilizzato in un quanto prima della SVC. Se è meno della metà, il sistema operativo aspetterà il prossimo ciclo di clock, altrimenti lo sposta in E-System. Questo meccanismo è detto \textbf{Preemption}.\par\quad
Se uno scheduler lavora in tempo reale, i processi da lui gestiti si diranno \textit{corretti} e produrranno un risultato giusto nell'intervallo di tempo giusto. In merito diremo inoltre:
\begin{itemize}
    \item \textit{Soft RealTime}; Se il processo è stato ultimato sforando di poco l'intervallo di tempo a disposizione.
    \item \textit{Hard RealTime}; Se il processo è stato ultimato entro l'intervallo di tempo a disposizione.
\end{itemize}
Ogni singolo processo ha poi un suo descrittore che fa parte di una struttura dati del sistema operativo le cui parti sono: ProcessIDm, Proprietà, Stato della CPU\footnote{Il salvataggio dello state nella memoria.}, Cache e FileID. Questo tipo di strutture è salvato dallo scheduler e si dice \textbf{Context Switch}. Tuttavia, essendo che necessita del tempo, tutte le istanze in cui esso avviene sono tempi persi.\par\quad
Quanto visto finora crea l'illusione per la macchina di avere una CPU per ogni singolo processo, idem per i dispositivi di I/O.

%

\section{Pila e gestione del segnale interrupt}
Avrai con ogni probabilità sentito parlare del termine "\textbf{Stack}". Conoscere il suo funzionamento è \textit{fondamentale} per comprendere appieno come i programmi vengono trattati dalla macchina. Si tratta di una zona di memoria con due caratteristiche:
\begin{itemize}
    \item \textit{Ristretta}; Vengono selezionati rispettivamente un indirizzo di fine ed uno di inizio per delimitare lo spazio apposito per il programma. I loro valori sono salvati in due registri posti all'inizio e la fine di questa zona di memoria.
    \item \textit{Riservata}; Ciò è necessario perché se altri processi dovessero accedere ad una zona di memoria già usata, si sfalserebbero o sovrascriverebbero i dati. 
\end{itemize}

\begin{minipage}{0.5\textwidth}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.5\linewidth]{Images/Stack.png}
        \caption{Divisione in parti della Pila}
        \label{fig:enter-label}
    \end{figure}
\end{minipage}
\begin{minipage}{0.5\textwidth}
    La Pila è divisa propriamente in quattro parti quando questa è ristretta per un programma:
    \begin{itemize}
        \item \textit{Codice}; Registri per il salvataggio del codice scritto.
        \item \textit{Dati Statici}; Registri per il salvataggio di costanti simboliche.
        \item \textit{Dati Dinamici o Heap}; Registri per la memoria temporanea.
        \item \textit{Ulteriore stack}; Il resto della pila non utilizzato per il nostro programma.
    \end{itemize}
\end{minipage}\newline

Tutto molto bello, ma che funzione svolge? È capace di allocare le variabili locali e passare parametri a funzioni, ed è proprio per quest'ultima abilità che ti voglio concentrato. Mediante l'utilizzo di \textit{funzioni} è possibile ottimizzare l'utilizzo della memoria, in quanto lo spazio eventualmente creato per queste "vive" fino al loro termine, rendendolo riutilizzabile.\par\quad
Detto ciò, esistono tre azioni \textit{illegali} che portano direttamente ad errori fatali:
\begin{itemize}
    \item Tentativo di accesso a zone di memoria al di fuori dello spazio creato per il dato processo; Se ciò accade, interviene il sistema operativo mediante una routine simil-interrupt per fermare il programma.
    \item Esecuzione di istruzioni che il processore non è abilitato ad effettuare; risulterà in un errore di Interrupt Service Routine.
    \item Lettura di sequenze di bits non integrate nell'ISA, di conseguenza irriconoscibili per la macchina; Avrà luogo una \textbf{TRAP}. Il microprocessore effettuerà una SVC per attivare l'ISR e fermare il processo. L'eventuale report sarà condiviso mediante registri.
\end{itemize}
Vediamo ora il comportamento della stack con un semplice programma in C.\newline

\begin{minipage}{0.5\textwidth}
    \begin{verbatim}
        void main(){
        
            int a, b, c;
            c = foo(a, b);
        }
        int foo(int d, int e){
        
            int f;
            ...
            return f;
        }
    \end{verbatim}
\end{minipage}
\begin{minipage}{0.5\textwidth}
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{Images/CStack.png}
        \caption{Posizionamento dei dati in Stack}
        \label{fig:enter-label}
    \end{figure}
\end{minipage}

Come puoi vedere, le variabili della funzione sono posizionate in registri precedenti a quelle presenti nel main; questo significa che lo spazio si crea all'indietro, ovvero con la regola \textbf{LIFO}\footnote{Last-in, First-out, ovvero Ultimo dentro, Primo fuori.}. Solitamente aiuta immaginare che la stack sia una pila di libri, dalla quale puoi rimuovere con facilità solamente l'ultimo impilato.\par\quad
Questo meccanismo è ottenuto posizionando il Program Counter in cima alle celle di memoria allocate per il main, insieme ad una \textit{necessaria} zona del main dove ritornare il valore elaborato, per evitare che si perda. Infine, terminata la funzione, lo spazio che è stato utilizzato deve essere liberato dall'utente.\par\quad
Anche il sistema operativo ha una propria stack, dove sono presenti PSW e PC per effettuare le routines quando richiesto. Nel momento in cui termina, i registri nominati vengono scaricati.\par\quad
Se non ricordi il significato dei registri qua presenti, invito a tornare indietro alla sezione apposita. Non c'è vergogna nel ripasso; non puoi sapere una cosa che credi di sapere.\newpage