11-11-25 Prog2

--- Lambda
Classi anonime semplificate, le quali implementano un'interfaccia con un singolo metodo e non possono avere variabili locali.
```
public interface SingleInterface {int singleMethod (int param); }

SingleInterface singleDec = param -> { param-1; }		// Quindi segnatura: parametro -> bloccoEsecutivo
// Stampa singleDec.singleMethod(3) ritorna 2.
```
Lambda utili per un codice coinciso, ma sono fondamentalmente zucchero sintattico. Non cambia nulla da un punto di vista di performance.

-- Varargs
Si può passare una variabile contenente il numero di argomenti ad un metodo, con segnatura generale methodName (type ... args)
```
public static void main (String[] args) {
	System.out.println(min(1, 0, 5)); 					// the output is ’0 ’, the ints are passed as an array
	System.out.println(min(3, 7, 2, 6, 9)); 			// the output is ’2 ’, same behavior
}

static int min(int... values) { 						// values is translated into an array
	int res = Integer.MAX_VALUE; 						// with the correct size

	for (int v : values) {
		if (v < res) res = v;
	}

	return res;
}
```
Le varargs sinergizzano con classi anonime (quindi anche lambda) per ridurre la dimensione del codice e rendere una scrittura più chiara e coincisa.

```
public interface SingleInterface { int singleMethod(int... params); }

SingleInterface singleInc = new SingleInterface () { 					// anonymous class
	@Override
	public int singleMethod (int... params) { return params [0] + 1; }
}

SingleInterface singleDec = params −> params [0] − 1; 					// with a lambda

System.out.println(singleInc.singleMethod(3, 4, 5)); 					// the output is ’4 ’
System.out.println(singleDec.singleMethod(3, 2) ); 						// the output is ’2 ’
```

-- Tipi generici
Quando ad uno stesso contenitore possiamo associare dati differenti, parliamo di polimorfismo parametrico.
A metodi e parametri è infatti consentito avere un tipo generico usando variabili dei tipi; consente di scrivere codice indipendente dal tipo di dato che gestisce.
Consideriamo un caso in cui è richiesto utilizzare un metodo dal funzionamento uguale per due tipi di dato diversi. Con le conoscenza acquisite finora si penserebbe di scrivere
due metodi ad-hoc, ma grazie a generics è possibile scriverla una volta sola e riutilizzarla senza troppi problemi.

```
public class Pair <T> { 					// class type parameter declaration. Generics is given with <T>.
	private T first, second;

	public Pair(T first, T second) {
		this.first = first;
		this.second = second;
	}

	public T getFirst () { return first; } 		// type parameter declaration
	public T getSecond () { return second; } 	// not needed here
}

// La classe è utilizzabile con più tipi, non è richiesto il type cast.
Pair <String> p = new Pair <String> ("one", "two");
Pair <Integer> q = new Pair <Integer> (1, 2);
```

Si possono dichiarare più tipi generics allo stesso tempo <T1, T2, ..., Tk> e possono essere creati genericamente tipi, metodi, classi, referenze e interfacce.
Tendenzialmente si nominano come: T(ype), E(lement), K(ey), V(alue).

// Interfaccia comparabile con generics
java.lang.Comparable<T>	è un interfaccia contenente int compareTo(T obj); Fondamentalmente parliamo di una classe apposita per le comparazioni, alla quale viene dato un generic.
I metodi potranno poi essere overridati per essere adattati al caso in esame.
Ritorna 0 se gli oggetti sono uguali, un intero > 0 se il primo oggetto è maggiore dell'altro, mentre un numero < 0 se è minore.

```
public class Student extends Person implements Comparable <Student> {
	...
	@Override	// Per adattare il metodo alla classe specifica.
	public int compareTo (Student other) {
		return this.matricola − other.matricola;
	}
}
```

java.lang.Iterable<E> è un'utile interfaccia contenente il metodo Iterator<E>, Iterator(), che a sua volta contiene metodi boolean HasNext(), E next().
Queste due interfacce sono inutilizzabili da sole; per usare iterable è necessario implementare iterator, altrimenti sarà impossibile scorrere gli oggetti dati.
	1. Dichiara l'iterable implementato dall'interfaccia, l'oggetto sta dentro le <>, detto operatore diamond.
	2. Definisci costruttore e overrida la funzione Iterator() per adattarne il comportamento.
	3. Dichiara l'iteratore per scorrere l'oggetto in esame, poi overrida le funzioni hasNext e next per adattarne il comportamento.
	
Attenzione che il tipo di referenza deve essere lo stesso di quello dei parametri dati ad istanziazione. Nel processo, da Java7, l'istanziazione del tipo è effettuata in autonomia
dal compilatore, quindi si può scrivere anche
```
Pair <Integer> intPair = new Pair <> (2, 4);
```
Per rendere la cosa ulteriormente astratta, possiamo usare la lettera T come placeholder della classe; il compiler la sostituirà senza lagnarsi alla classe Object. Chiamiamo
questa definizione "Tipo di parametro libero". Possono essere anche legati, specificando un limite di classe superiore o inferiore.
	- Unbounded: 
		```
		public class Pair <T> { // we want to use Person here
		private T first, second;
		}
		```
	- Bounded:
		```
		// Limite superiore
		class Clazz <T extends S1 & S2 & ... & Sk>
		// Limite inferiore
		class Clazz <T super S>
		```
	
Se T è legato, il compiler non si lagnerà per i relativi metodi dichiarati, poiché ha un limite al quale fermarsi.
	
```
public class Pair <T extends Person > { // we want to use Person here
	private T first , second;

	public Pair (T first , T second) {
		this.first = first;
		this.second = second;
	}

	public T getFirst () { return first.getName(); } // no error
	public T getSecond () { return second; } // T extends Person
}
```

--- Generics e ereditarietà
Gli iterabili C,D provenienti da una subclasse B non riconoscono come sovracclasse il padre A della sub B. Di conseguenza risultano incompatibili.

Possiamo usare il parametro Wildcard '?' nel diamond per indicare un tipo generico Oggetto libero. Non differisce da una normale dichiarazione di unbounded generic T, infatti
non sarà possibile usare metodi ad esso associati; tuttavia il vantaggio è che non richiede classi per essere usato. Puoi usarlo come parametro generale.
Puoi tuttavia legare ? specificando limite superiore o inferiore con extends/super. In tal caso puoi usare i metodi definiti con questo tipo.