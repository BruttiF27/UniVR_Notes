\section{Tipi primitivi, variabili e costanti, operatori e assegnamenti}
Supponendo che tu abbia frequentato o quantomeno ascoltato il corso di programmazione 1, la lettura risulterà nettamente più scorrevole. Infatti Java, per quanto riguarda le informazioni elementari, condivide una sintassi quasi uguale a quella di C, composta da:
\begin{itemize}
	\item \textbf{Parole chiave del linguaggio}: Hanno un significato speciale e non possono essere usate per la dichiarazione di variabili o funzioni.
	\item \textbf{Identificatori}: I nomi scelti per gli elementi di programmazione definiti nel linguaggio.
	\item \textbf{Operatori}: Simboli per effettuare operazioni.
	\item \textbf{Dati}: Valori delle variabili, le informazioni nel codice.
\end{itemize}
\noindent Si mantengono tutte le funzioni legate al linguaggio C per quanto riguarda tipi primitivi, operatori ed assegnamenti. Abbiamo quindi: \textbf{int}, \textbf{double}, \textbf{char}, aggiungendo \textbf{boolean} e \textbf{String}, quest'ultimo non primitivo, ma successivamente approfondito.\par
Di base ogni dato è considerato una variabile se non specificato altrimenti. Infatti, per la dichiarazione di costanti sarà necessario aggiungere la keyword \textbf{final}.

%

\section{Dichiarazione di classi e oggetti, this., parametri formali e attuali}
Le classi e gli oggetti sono il fulcro sul quale si basa la programmazione in Java e orientata agli oggetti in generale. Come già menzionato, le classi sono come un template, compresi di attributi e metodi, degli oggetti che verranno eventualmente istanziati. Per rendere una classe visibile ad altri file, sarà necessario dichiararla come public.
\begin{lstlisting}[language=Java]
	// Dichiarazione della classe Date nel file Date.java
	public class Date {
		
		// Scope dei campi della classe, questi sono attributi...
		int day, month, year;
		
		// ...e questo un metodo.
		String printDate() {
			return day + "/" + month + "/" + year;
		}
	}
\end{lstlisting}
\begin{lstlisting}[language=Java]
	// Dichiarazione della classe MainDate nel file MainDate.java
	public class MainDate {
		public static void main(String[] args) {
		
			// Istanziazione dell'oggetto Today
			Date Today = new Date();
		}
	}
\end{lstlisting}
\noindent Come si può vedere, la classe rappresenta il corpo contenente tutto il codice, mentre gli oggetti vengono istanziati in un altro file, ove richiesto, con la keyword \textbf{new}. Questa istruzione fa sì che venga allocato spazio sufficiente per contenere i dati dell'oggetto.


% TODO this.
% TODO parametri formali e attuali



%

\section{Metodo costruttore, costruttore di default e overloading}



\begin{comment}
	\noindent Si può estendere il discorso introducendo i concetti di \textbf{modificatore} e \textbf{funzione costruttore}. Il primo indica la modalità di accesso alla struttura e può essere usato sia per classi che oggetti, ed il secondo è un metodo dello stesso nome della classe che viene eseguito alla creazione di un nuovo oggetto. Per esempio, consideriamo il seguente codice all'interno della classe Date, dichiarata prima:
	\begin{lstlisting}[language=Java]
		// Funzione costruttore. Qui popola le variabili dell'oggetto. Modificatore public.
		public Date(int day, int month, int year) {
			// "this." indica la locazione dell'oggetto corrente.
			this.day = day;
			this.month = month;
			this.year = year;
		}
		
		// Metodo isFirstDay con modificatore static. Non ha accesso a campi non statici.
		static boolean isFirstDay(int day) {
			if (day == 1) return true;
			else return false;
		}
	\end{lstlisting}
\end{comment}

%

\section{Modificatori e visibilità}
Modificatori in generale e modificatori di accesso, visibilità.




\begin{comment}
	
	\noindent Nello specifico, per quanto riguarda i modificatori, abbiamo \textbf{public}, rendendo accessibili i dati senza limitazioni e \textbf{private}, che blocca l'accesso dall'esterno della classe. Questi specificano le modalità di accesso. Un altro modificatore presente nello snippet è \textbf{static}, che rende il metodo utilizzabile a prescindere dall'oggetto. Vediamo ora come istanziare un oggetto, a partire dagli snippet del file Date.java di prima:
	\begin{lstlisting}[language=Java]
		public class MainDate {
			public static void main(String[] args) {
				
				// Utilizzo di isFirstDay fuori oggetto. Possibile dato static.
				System.out.println(Date.isFirstDay(1));
				
				// Creazione dell'oggetto today e stampa con il metodo printDate.
				Date today = new Date(14, 10, 2024);
				System.out.println(today.printDate());
			}
		}
	\end{lstlisting}
	
	
	...
	
	
	Per \textbf{incapsulamento} si intende un raggruppamento di dati e metodi, i quali lavorano sui primi. Consente di avere una visuale più compatta riguardo ai campi di ogni classe. Se alcuni campi sono poi dichiarati con il modificatore \textbf{private}, l'incapsulamento esprime il suo massimo potenziale di sicurezza, consentendo l'\textbf{information hiding} e rendendo accessibili i campi solamente tramite gli appositi metodi.
	\begin{lstlisting}[language=Java]
		public class Person {
			// Dichiarare senza modificatori setta public di base
			String name;
			private int age = -1;
			
			Person(String name) { this.name = name; }
			
			// Metodo per segnalare se age risulta illegale
			void changeAge(int age) {
				if (age > 0 && age <= 122) this.age = age;
				else System.out.println("Invalid age.");
			}
		}
	\end{lstlisting}
	La variabile age in questo caso diventa accessibile solo tramite il metodo changeAge, perché risulta inaccessibile al di fuori. La corretta gestione di questa dinamica si ha introducendo due metodi appositi, il \textbf{getter}, che riceve il dato per poi assegnarlo all'oggetto, ed il \textbf{setter}, che si assicura sia in un formato corretto. Nello snippet appena visto, changeAge è inserito come setter.
\end{comment}

%

\section{Costrutti condizionali e ciclici}




\begin{comment}
	content...
\end{comment}

%

\section{Array e tipi enumerativi}
In Java è possibile dichiarare \textbf{array} mono- e bidimensionali; sono visti come oggetti speciali allocati in heap, quindi definiti in runtime, e da un punto di vista pratico sono sequenze di puntatori ad oggetto. Alcuni aspetti importanti sono:
\begin{itemize}
	\item In mancanza di inizializzazione, la JVM li setta a null.
	\item Post-dichiarazione, sarà impossibile modificarne la lunghezza.
	\item Essendo sequenze di puntatori, il metodo equals non funzionerà come negli oggetti normali.
\end{itemize}
\begin{lstlisting}[language=Java]
	// Dichiarazione di array
	int[] arr = new int[dimensione];
	// Scrittura in un indice specifico
	arr[numeroIndice] = NomeClasse(eventuali_parametri);
	// Accesso ad un elemento in un indice specifico
	int var = arr[numeroIndice];
\end{lstlisting}
\noindent Per una manipolazione corretta e agevolata di array è utile la libreria \textbf{java.util.Arrays}, contenente metodi per effettuare confronti e stampare il contenuto. Verrà approfondita più avanti.





\begin{comment}
	Questi sinergizzano ovviamente col ciclo for, il quale ha una forma enhanced con una sintatti più compatta.
	\begin{lstlisting}[language=Java]
		// Enhanced for loop, equivalente alla scrittura classica
		for (tipoVariabile : espressioneIterabile);
		// Confronta se due array hanno gli stessi elementi
		Arrays.equals(arr1, arr2);
		// Stampa ogni elemento dell'array in formato stringa
		Arrays.toString(arr);
	\end{lstlisting}
	\noindent Ovviamente, nella creazione di matrici, è possibile usare tutti i metodi appena visti; ci sono poche differenze rispetto a quanto già visto in C.
	\begin{lstlisting}[language=Java]
		// Dichiarazione ed inizializzazione di una matrice di interi
		int[][] matrix = {{1,2,3}, {4,5,6}, {7,8,9}};
		// Per scambiare facilmente righe o colonne puoi prendere il puntatore.
		int[] tmp = matrix[0];
		matrix[0] = matrix[matrix.length-1];
		matrix[matrix.length-1] = tmp;
		// Stampa gli elementi di una matrice
		for (int[] row:matrix) System.out.println(Arrays.toString(row));
	\end{lstlisting}
	\noindent Infine, abbiamo, sempre come in C, i tipi per le \textbf{enumerazioni}. Rappresentano un insieme finito di costanti e risultano utili per definire valori arbitrari utilizzati più volte, non richiedendo la dichiarazione di variabili per ogni blocco di codice. Vengono anche loro con alcuni metodi utili:
	\begin{lstlisting}[language=Java]
		// Dichiarazione
		public enum nomeEnum {
			CST1, CST2, ...
		}
		
		// Ritorna il nome della costante assegnata all'oggetto
		nomeObjEnum.name(nomeOggetto.campo);
		// Ritorna il valore della costante assegnata all'oggetto
		nomeObjEnum.ordinal(nomeOggetto.campo);
	\end{lstlisting}
\end{comment}

%