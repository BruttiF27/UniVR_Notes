R è linguaggio di programmazione case-sensitive. Viene utilizzato per l'analisi statistica dei dati e la loro visualizzazione, statistica descrittiva, machine learning, manipolazione dei dati, datamining e anche nella ricerca scientifica.\par
Basato su un codice open-source, la sua sintassi è estremamente flessibile e a tratti simile a C. È inoltre un linguaggio diviso in pacchetti, ovvero insiemi di funzioni create da altri utenti. I files con i quali lavoreremo hanno l'estensione ".R" e sono detti \textbf{R-Scripts}; infatti ciò che andremo a scrivere e far elaborare dal software sono fondamentalmente dei testbench per ritornare determinati risultati o comportamenti. Per lavorare su di essi è necessario l'uso del terminale, e dove è possibile utilizzare l'interfaccia di R innata, è consigliato, e così faremo nel corso, utilizzare l'ambiente di sviluppo \textbf{R Studio}.\par 
Prima di iniziare è bene installare ogni pacchetto necessario per lo studio di probabilità e statistica; il comando da terminale è:
\begin{verbatim}
	# Questo è un commento
	> install.package("nomePacchetto")
\end{verbatim}
\noindent Ho utilizzato due scritture diverse. Nel corso della sezione sarà considerata scrittura al terminale qualunque cosa vada dopo il carattere "$>$", altrimenti è uno script su file .R. Ora che abbiamo tutto pronto possiamo iniziare a lavorare col linguaggio.

%

\section{Componenti base del linguaggio}
\subsection{Variabili, operatori e strutture dati}
Il linguaggio R consente di stampare a video stringhe, numeri ed operazioni sia che essi siano contenuti in una variabile dichiarata o meno:
\begin{verbatim}
	A <- "Hello World!"
	A	# Stampa il contenuto della variabile A
	B <- 27
	B	# Stessa roba, ma per B
	C <- 5 + 5
	C	# Avrai capito ora, no?
	A <- NULL	# Rendo A vuota
	remove(A)	# Rimuovo A dall'ambiente
\end{verbatim}
\noindent Bisogna solo tenere a mente che non è possibile dichiarare variabili il cui nome inizia con un numero o hanno lo stesso nome di una parola chiave. R supporta i seguenti tipi di dato, assegnati automaticamente all'inizializzazione della variabile:
\begin{itemize}
	\item \textbf{Numerico}, come $[2, 10, 3.75]$. Considera quindi anche i razionali.
	\item \textbf{Intero}, come $[10L, 32L, 99L]$. La lettera L è necessaria per dichiarare il numero come intero.
	\item \textbf{Complesso}, come $[2i, 4i, 28i]$. La i indica l'unità immaginaria.
	\item \textbf{Carattere}, come $["a", "Pallw", "30", "TRUE"]$. Notare che qualunque cosa all'interno di apici verrà visto come stringa.
	\item \textbf{Booleano}, come $[TRUE, FALSE]$. Autoesplicativo, dai.
\end{itemize}
\noindent L'allocazione della memoria è gestita dal linguaggio stesso e la variabile viene salvata nell'\textbf{ambiente} di lavoro. Rimane utilizzabile fin quando non la si rimuove. Una cosa di cui tener conto è che i caratteri si possono concatenare per creare delle stringhe, in questo modo:
\begin{verbatim}
	c1 <- c2 <- c3 <- "A" # Associa il carattere "A" a multiple variabili.
	cat("Questo gioco è un:", c1, c2, c3)
\end{verbatim}
\noindent Per quanto riguarda gli \textbf{operatori}, abbiamo la possibilità di effettuare le operazioni elementari, potenze, modulo e divisione intera con rispettivamente $[+, -, *, /, ^, \%\%, \%/\%]$, ma esistono anche funzioni diverse per facilitarci la vita:
\begin{verbatim}
	abs(-4.2)			# Torna il valore assoluta del dato inserito
	sqrt(9)				# Torna la radice quadrata del dato inserito
	min(10, 5, 15)		# Torna il valore minimo dei dati inseriti
	max(10, 5, 15)		# Torna il massimo dei dati inseriti
	ceiling(1.4)		# Torna il numero approssimato per eccesso (2)
	floor(1.4)			# Torna il numero approssimato per difetto (1)
\end{verbatim}
\noindent Abbiamo poi i comparatori, la cui sintassi è uguale spiccicata a C:
\begin{verbatim}
	x == y 	# x uguale a y
	x != y	# x diverso da y
	x < y	# x minore di y
	x <= y	# x minore o uguale a y
	x > y	# x maggiore di y
	x >= y	# x maggiore o uguale a y
\end{verbatim}
\noindent Come anche gli operatori logici:
\begin{verbatim}
	&&	# AND logico, torna vero se lo sono ambo gli elementi
	||	# OR logico, torna vero se lo è almeno un elemento
	!	# NOT logico, inverte il valore dell'elemento
\end{verbatim}
\noindent Non fermiamoci qui, il vero potenziale di R sta anche nelle sue sei strutture dati innate, le quali sono:
\begin{itemize}
	\item \textbf{Vettori}; Una lista di oggetti dello stesso tipo. Presentano le stesse dinamiche viste in C con migliori modalità di accesso.
	\begin{verbatim}
		# Vettore di elementi 5, 10, 15, 20, 25
		v1 <- c(5, 10, 15, 20, 25)
		# Vettore di elementi in sequenza da 1 a 5	
		v2 <- 1:5
		# Vettore di elementi da 5 a 25 a passi di 5
		v3 <- seq(from = 5, to = 25, by = 5)
		# Vettore degli elementi di v3 ripetuti tre volte
		v4 <- rep(v3, times = 3)
		# Accesso al valore del vettore v1 in posizione 1
		v1[1]
	\end{verbatim}
	\noindent È evidente che è possibile utilizzare il vettore come una semplice variabile, rendendo possibile darlo in pasto alle funzioni senza problemi di memoria. Abbiamo inoltre alcune funzioni innate utili per lavorare con questa struttura di dati, dove "v" indica il vettore:
	\begin{itemize}
		\item length(v): Calcola la lunghezza del vettore.
		\item max(v), min(v): Calcolano valore massimo e minimo del vettore.
		\item mean(v): Calcola la media dei valori nel vettore.
		\item sum(v): Calcola la somma di tutti gli elementi del vettore.
		\item cumsum(v): Calcola la somma cumulativa di ogni elemento.
		\item sort(v): Ordina il vettore.
	\end{itemize}
	\item \textbf{Liste}; Collezioni di dati ordinate e modificabili. Hanno un comportamento uguale ai vettori ed è possibile aggiungervi elementi come anche concatenare più liste:
	\begin{verbatim}
		# Dichiarazione delle liste l1, l2
		l1 <- list("Dio", "Gesù", "Maria")
		l2 <- list("Pietro", "Paolo", "Giovanni")
		
		# Accesso all'elemento in posizione 3 di l1
		l1[3]
		
		# Aggiungo l'elemento "Cane" alla lista l1
		append(l1, "Cane")
		
		# Aggiungo l'elemento "Mascio" in posizione 2 alla lista
		append(l1, "Mascio", after = 2)
		
		# Concatenazione di l1 e l2 in l3
		l3 <- c(l1, l2)
	\end{verbatim}
	\item \textbf{Matrici}; Dataset a due dimensioni composto da righe e colonne.
	\begin{verbatim}
		# Dichiarazione di una matrice, lega i due vettori come colonne.
		mat1 <- cbind(c(1, 2, 3), c(1, 2, 3))
		# Dichiarazione di una matrice, lega i due vettori come righe.
		mat2 <- rbind(c(1, 2, 3), c(1, 2, 3))
		
		# Accesso a elementi in colonne da 1 a 2 e righe da 2 a 3.
		mat1[2:3,1:2]
		
		# Rimuove la prima riga, nessun comando per le colonne.
		mat1[-1,]
		
		# Riempie una matrice di i righe e j colonne del valore n
		mat3 <- matrix(n, i, j)
		
		# Crea una matrice identità di dimensione k
		matIdt <- diag(k)
	\end{verbatim}
	\noindent Le operazioni utilizzabili dalle matrici seguono quelle viste in algebra lineare, vale a dire somma, sottrazione fra vettori o matrici e divisione, moltiplicazione per scalari, vettori o matrici. Il risultato deve essere salvato in una variabile diversa e l'operazione si scrive semplicemente come fossero due numeri. Seguono altre funzioni utili, con "A" matrice:
	\begin{itemize}
		\item det(A): calcola il determinante di una matrice.
		\item qr(A): Calcola la decomposizione QR.
		\item solve(A): Fa l'inversa di una matrice.
		\item nrow(A), ncol(A): Ritornano il numero di righe o colonne di una matrice.
		\item rowSums(A), colSums(A): Fanno la somma dei valori di ogni riga o colonna. 
		\item rowMeans(A), colMeans(A): Calcola la media dei valori di ogni riga o colonna. 
		\item dim(A): Calcola la dimensione di una matrice.
	\end{itemize}
	\item \textbf{Array}; Collezione di elementi dello stesso tipo che può avere più di due dimensioni. Usarli solo se è necessario avere più di due dimensioni.
	\begin{verbatim}
		# Dichiarazione di un array a più dimensioni
		a2 <- array(c(1:12), dim = c(2, 3, 2))
		
		# Stampo l'intero array
		a2
		
		# Accedo alle posizioni i-1st dim, j-2nd dim, k-3rd dim.
		a2[2, 3, 2]
	\end{verbatim}
	\item \textbf{Dataframes}; Collezione di dati di vario tipo salvata in un formato matriciale. Ne consegue che siano composti da righe e colonne, le quali possono essere viste come singoli vettori che contengono un tipo di dato; ciò comporta che \textit{la struttura può contenere diversi tipi allo stesso tempo}:
	\begin{verbatim}
		# Dichiaro un dataframe
		df1 <- data.frame(
			mount = c("Everest", "K2", "Fuji"),
			height = c(8848, 8611, 3776),
			todo = c(TRUE, TRUE, FALSE)
		)
		
		# Stampo il dataframe
		df1
		
		# Accedo alla singola colonna mount
		df1$mount
	\end{verbatim}
	Essendo inoltre strutturata come una matrice, sarà possibile utilizzare le sue stesse funzioni.
	\item \textbf{Fattori}; Utilizzati per lavorare con dati categorizzati. Questa struttura può contenere solo un insieme di valori fissati detti \textbf{livelli}, i quali vengono dati nella dichiarazione.
	\begin{verbatim}
		# Dichiaro il fattore f1 col set marital_status di relativi elementi
		f1 <- marital_status <- factor(c("married", "single", "single",
		"divorced", "married"))
		
		# Stampo il fattore
		f1
		
		# Stampo i singoli livelli (ignora ripetizioni)
		levels(f1)
		
		# Provo ad inserire "hey" come livello, fallendo.
		f1[1] <- "Hey"	# In questo caso genererà NA
	\end{verbatim}
\end{itemize}

%

\subsection{Costrutti condizionali, cicli e funzioni}
R mantiene i costrutti condizionali e i cicli, quindi abbiamo le costruzioni "if-else", "while" e "for".
\begin{verbatim}
	a <- 200
	b <- 33
	
	# Funzionamento del costrutto if else
	if (b > a) {
		print("b is greater than a")
	} else if (a == b) {
		print("a and b are equal")
	} else {
		print("a is greater than b")
	}
	
	c <- 40
	
	# Funzionamento del costrutto while
	while(b < c) {
		b <- b+1
	}
	
	dice <- c(1, 2, 3, 4, 5, 6)
	
	# Funzionamento del costrutto for (variable in sequence)
	for (x in dice) {
		print(x)
	} 
\end{verbatim}
\noindent Per la strutturazione corretta di uno script più complesso sarà necessario dividere il tutto in \textbf{funzioni}:
\begin{verbatim}
	# Dichiarazione della funzione my_function
	my_function <- function(x) {
		return (5 * x)
	}
	
	print(my_function(3))
	print(my_function(5))
	print(my_function(9))
\end{verbatim}

%

\subsection{Grafici e salvataggio immagini}
R ha varie funzioni di base per la rappresentazione dei dati su grafici; possiamo creare i seguenti tipi:
\begin{itemize}
	\item \textbf{Grafici a barre}
	\begin{verbatim}
		ages = 20:29
		students = c(2,1,5,3,4,2,0,2,1,0)
		
		barplot(students,
			xlab = "Age of students",		# Nome asse x
			ylab = "Number of students",	# Nome asse y
			names.arg = ages				# Dati posti sull'asse x
		)
	\end{verbatim}
	\item \textbf{Grafici a linea}
	\begin{verbatim}
		x <- c(1, 2, 3, 4, 5)
		y <- c(2, 4, 6, 8, 10)
		
		# Creo un grafico di tipo lineplot, con dati x,y
		plot(type = "l", x, y,
		xlab = "X values",		# Nome dei valori sulle x
		ylab = "Y values",		# Nome dei valori sulle y
		main = "X and Y values",# Nome del grafico
		col = "red"				# Colore dei dati
		)
	\end{verbatim}
	\item \textbf{Istogrammi}; hist()
	\item \textbf{Boxplots}; boxplot()
	\item \textbf{Grafici di dispersione}; plot()
	\item \textbf{Mappe di calore}; heatmap()
	\item \textbf{Grafici di densità}; plot(density(...))
\end{itemize}
\noindent È possibile aggiungere più grafici in un singolo foglio, a discapito dello spazio. Per farlo è necessario usare il seguente comando:
\begin{verbatim}
	x = 1:6
	y = c(33, 11, 5, 9, 22, 30)
	
	# Gestione del layout. Ho scritto una matrice 2x2.
	par(mfrow = c(2,2))
	
	# Le posizioni si ordinano da sole.
	barplot(y, main = "Barplot", names.arg = x)
	barplot(y, main = "Horizontal Barplot",
	names.arg = x, horiz = TRUE)
	plot(x, y, type = "l", main = "Line plot")
	plot(x, y, main = "Scatter plot", col = "red")
\end{verbatim}
\noindent Per quanto riguarda l'export, basta cliccare il pulsante corretto nell'interfaccia di R-Studio. Nessun bisogno di stressarsi con vari comandi. Inoltre per fare grafici migliori è preferibile usare il pacchetto \textbf{ggplot2}, del quale parleremo nelle prossime sezioni.

%

\section{Gestione scripts e pacchetti aggiuntivi}
\subsection{Salvataggio, caricamento e fonti}
La voglia di ridichiarare le variabili ogni volta che si vuole lavorare con R è pari a zero; infatti è possibile salvarle in due formati:
\begin{itemize}
	\item \textbf{.RData}; Formato di file binario usato per salvare uno o più oggetti R in un singolo file.
	\begin{verbatim}
		# Per salvare l'environment
		save(nomeOggetto)
		# Per caricarlo in un file diverso
		load(nomeOggetto)
	\end{verbatim}
	\item \textbf{.RDS}; Formato di file binario usato per salvare un singolo oggetto R in un file.
	\begin{verbatim}
		# Per salvare l'oggetto in RDS
		saveRDS(nomeOggetto)
		# Per caricarlo in un file diverso
		readRDS(nomeOggetto)
	\end{verbatim}
\end{itemize}
\noindent È possibile dividere un progetto in più files, per poi chiamare lo script nel momento necessario tramite la funzione \textbf{source()}. Un grande insieme di files .R si dice \textbf{pacchetto}.

\subsection{Dplyr}
Il pacchetto \textbf{Dplyr} è creato per la manipolazione dei dati, consentendo di trasformare e riassumere tabelle di dati usando delle funzioni apposite. Nel nostro caso, lo utilizzeremo per l'organizzazione degli elementi nei dataframes. Le principali funzioni di dplyr sono:
\begin{itemize}
	\item \textbf{Operatore pipe} \%$>$\%; Invia il risultato della funzione precedente alla successiva.
	\item \textbf{filter()}; Filtra i dati in base ad una condizione specificata.
	\item \textbf{select()}; Seleziona la colonna indicata in base al nome.
	\item \textbf{mutate()}; Modifica colonne esistenti o ne crea nuove.
	\item \textbf{arrange()}; Ordina le righe.
	\item \textbf{group\_by()}; Raggruppa i dati per effettuare operazioni in ogni gruppo.
	\item \textbf{summarize()}; Fa un sommario delle statistiche date.
\end{itemize}

% TODO INSERISCI ESEMPIO CON L'ESERCIZIO 5 DI CALGARO (SCHEDA 1)

\subsection{Statistica descrittiva e Ggplot2}
Abbiamo discusso dello scopo della statistica descrittiva nella parte di teoria; con R possiamo usare le seguenti funzioni e studiare i dati in nostro possesso:
\begin{itemize}
	\item \textbf{Media}: mean().
	\item \textbf{Mediana}: median().
	\item \textbf{Differenza fra valore minimo e massimo}: range().
	\item \textbf{Scarto interquartile}: IQR().
	\item \textbf{Varianza}: var().
	\item \textbf{Deviazione standard}: sd().
	\item \textbf{Skewness}: skewness().
	\item \textbf{Curtosi}: kurtosis().
	\item \textbf{Covarianza}: cov().
	\item \textbf{Coefficiente di correlazione}: cor().
\end{itemize}
\noindent Altre funzioni di R base:
\begin{itemize}
	\item \textbf{summary()}: Fa un sommario di un dataset, comprende minimo, massimo, quartili, media e mediana di ogni variabile.
	\item \textbf{table()}: Crea una tavola di contingenza per le variabili categoriche, mostrando la frequenza di ogni combinazione di categoria.
	\item \textbf{prop.table()}: Crea una tavola di contingenza per le variabili categoriche, mostrando la proporzione di ogni combinazione di categoria.
	\item \textbf{quantile()}: Calcola il valore di un quantile specifico.
\end{itemize}
\noindent Per quanto riguarda le operazioni matematiche, bisogna prendere la funzione che svolge quel compito ed eventualmente stampare i risultati a video in forma leggibile utilizzando le verbs di dplyr come \textbf{summarize()}. Per la rappresentazione grafica seria, invece, useremo il pacchetto \textbf{ggplot2}, il quale consente, tramite una scrittura chiara e stratificata, di creare grafici altamente personalizzabili, di ogni tipo.\par 
La struttura a strati necessita che le parti siano scritte nel seguente ordine:
\begin{enumerate}
	\item \textbf{ggplot(data = ...)}: Inizializza il grafico.
	\item \textbf{aes()}: Dà nome agli assi e setta i colori.
	\item \textbf{geom\_*()}: Determina il tipo di grafico.
	\item \textbf{scale\_color\_manual(values = ...)}: Setta manualmente i colori dei dati nel grafico.
	\item \textbf{labs()}: Dà i nomi alle varie parti del grafico.
\end{enumerate}
\noindent Vediamo un esempio:
\begin{verbatim}
	# Usa le librerie utili
	library("palmerpenguins")
	library("ggplot2")
	
	# Dichiarazione della variabile per il grafico
	mass_flipper <- ggplot(data = penguins) + 
		aes(x = flipper_length_mm, y = body_mass_g) +
		geom_point(aes(color = species, shape = species), size = 3, alpha = 0.8) +
		scale_color_manual(values = c("darkorange", "purple", "cyan4")) +
		labs(title = "Flipper length and body mass",
		subtitle = "Colored by Adelie, Chinstrap and Gentoo Penguins",
		x = "Flipper length (mm)",
		y = "Body mass (g)",
		color = "Penguin species",
		shape = "Penguin species") +
		theme(legend.position = "bottom")
	
	mass_flipper
\end{verbatim}
\noindent Con questa formula è possibile costruire ogni tipo di grafico per ogni evenienza. Questo comprende anche tabelle di frequenza, boxplots, mappe di calore, istogrammi etc. Familiarizzarci è più che consigliato.

%

\section{Elementi di probabilità}
Come ci si può aspettare, per calcolare la probabilità di un evento è necessario ripetere dei test. Il modo migliore per farlo è utilizzare cicli for, mentre per ottenere valori casuali in un campione si usa la funzione \textbf{sample()}. Se è necessario pescare sempre gli stessi valori, si può settare il seed di pesca con \textbf{set.seed()}.

% TODO INSERISCI ESEMPIO

\subsection{Coefficiente binomiale}
Per calcolare un coefficiente binomiale si utilizza la funzione \textbf{choose(n,k)} ed è usata per il calcolo combinatorio.

% TODO INSERISCI ESEMPIO (ESERCIZIO 5 LAB3)

\subsection{Formula di Bayes}

% TODO INSERISCI ESEMPIO (ESERCIZIO 6 LAB3)

%

\section{Variabili aleatorie}
\subsection{Binomiali}
\subsection{Di Poisson}
\subsection{Uniformi}
\subsection{Normali}
\subsection{Esponenziali}

%

\section{Statistica inferenziale}
e stima di parametri
\subsection{Approssimazione delle distribuzioni binomiali e normali}
\subsection{Teorema del limite centrale}
\subsection{Stimatori di massima verosimiglianza}
\subsection{Intervalli di confidenza e testing delle ipotesi}

%

\section{Regressione lineare semplice}