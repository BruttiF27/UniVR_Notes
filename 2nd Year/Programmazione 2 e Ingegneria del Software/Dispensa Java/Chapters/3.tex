\section{Incapsulamento}
L'incapsulamento è un concetto che ha origine nelle modalità di interazione nel mondo reale. Così come per interagire con una persona si usa la voce per ottenere informazioni specifiche, allo stesso modo gli oggetti comunicano con interfacce apposite al fine di ritornare dati. Questa filosofia si ottiene controllando l'accesso ai dati tramite le keyword dei modificatori di accesso. Più precisamente, bisogna:
\begin{enumerate}
	\item Dichiarare gli attributi di una classe come \textbf{privati}, per renderli inaccessibili ad altre classi al di fuori di questa.
	\item Creare dei metodi \textbf{pubblici} per accedere, modificare e riportare gli attributi privati in maniera controllata, talvolta con dei controlli per assicurarsi che i dati siano presentati con certe caratteristiche. Questi metodi si chiamano \textbf{setter}, per assegnare il dato all'oggetto, e \textbf{getter}, per accedere al dato dell'oggetto.
\end{enumerate}
\begin{lstlisting}[language=Java]
	public class Date {
		private int day, month, year;
		
		// Metodo setter per garantire che giorno sia un valore corretto
		public void setDay (int g) {
			if (j >= 1 && j<= 31) giorno = g;
			else System.out.println("Invalid day");
		}
		
		// Metodo getter per ritornare il valore in sicurezza
		public int getDay () { return day; }
		
		public void setMonth (int m) {
			if (m <= 1 && m <= 12) month = m;
			else System.out.println("Invalid month");
		}
		
		public int getMonth () { return month; }
	
		public void setYear (int y) {
			if (y <= 0) year = y;
			else System.out.println("Invalid year");
		}
		
		public int getYear () { return year; }
	}
\end{lstlisting}

%

\section{Ereditarietà}
Quello di \textbf{ereditarietà} è un concetto strettamente legato all'insiemistica. Partiamo dal presupposto che esiste un insieme universo, il quale comprende ogni singola altra cosa nel mondo; in Java, le classi funzionano con la medesima dinamica. Tutte le classi sono un sottoinsieme improprio di \textbf{Object}, la quale presenta i seguenti metodi per noi importanti:
\begin{itemize}
	\item \textbf{protected Object clone()}: Istanzia e ritorna una copia dell'oggetto richiesto.
	\item \textbf{boolean equals(Object obj)}: Controlla se un oggetto è uguale a quello chiamante.
	\item \textbf{int hashCode()}: Ritorna il valore dell'hashcode dell'oggetto chiamante, ovvero la parte sinistra alla chiocciola della reference.
	\item \textbf{String toString()}: Ritorna una rappresentazione dell'oggetto sotto forma di stringa.
\end{itemize}
\noindent Tutte le classi, e quindi anche i tipi, sono \textbf{estensioni} della classe Object, e di conseguenza potranno chiamare ed eseguire i metodi in essa contenuti. Questo concetto è naturalmente replicabile con ulteriori sottoclassi, quindi ci è concesso creare nuovi metodi e campi riutilizzabili in più file senza che vengano ridefiniti. La potenzialità di questo paradigma sta nella riduzione all'estremo di codice ripetuto; le sottoclassi sono quindi capaci di attingere da ciò che è definito nella superclasse, e, nel caso dei metodi, fare ciò che è chiamato \textbf{overriding}\par
Supponiamo ora di avere una classe "Vehicle". Il concetto di veicolo è specificabile in sottoinsiemi come automobili, biciclette e simili. In Java ciò si traduce come:
\begin{lstlisting}[language=Java]
	public class Vehicle {
		protected int num;
		protected int getNum() { /* Blocco di codice */}
		public Vehicle { /* Blocco del costruttore */ }
	}
	
	// Estensione di Vehicle, chiama il metodo per ottenere il numero.
	public class Car extends Vehicle {
		public Car { 
			this.num = super.getNum();
		}
	}
	
	// Ridefinizione di getNum per mantenere lo stesso nome e semplificare il codice
	public class Bicycle extends Vehicle {
		@Override
		public int getNum() { /* Ridefinizione del codice */ }
	}
\end{lstlisting}
\noindent L'accesso a campi e metodi della superclasse avviene tramite la keyword \textbf{super}, se questi sono stati dichiarati come pubblici o protetti. Questa parola è anche strettamente legata al metodo costruttore; questo non è ereditato dalle sottoclassi, tuttavia è necessario che queste abbiano anche le caratteristiche della superclasse e siano costruite in tali termini. In soldoni, i costruttori non sono ereditati ed ogni sottoclasse ha bisogno del prorpio, ma quest'ultimo chiamerà necessariamente il costruttore della sovracclasse con super().\par
La ridefinizione è invece per prima cosa segnalata da \textbf{@Override}, per poi riscrivere il blocco di codice. Quest'ultima feature è particolarmente utile per mantenere il numero di nomi basso e rendere il codice più chiaro a livello di struttura.\par
Un'ultima caratteristica del linguaggio utile è la possibilità di controllare se una classe è superclasse di un'altra, con la keyword \textbf{instanceof}. Per esempio, in un codice che rappresenta Person, Student, Lecturer e Sam avremo:
\begin{lstlisting}[language=Java]
	Student sam = new Student();
	
	(sam instanceof Student)	// True, Identita'.
	(sam instanceof Person)		// True, Person sovracclasse di Student.
	(sam instanceof Lecturer)	// False, Student non legato a Lecturer.
	(sam instanceof Object)		// Tautologia.
\end{lstlisting}
\noindent Un compito comune da eseguire in campo di ereditarietà ed istanziazione di oggetti è controllare se questi siano uguali o meno; come già specificato, la classe Object ha con sé il metodo equals(), che consente di fare proprio questo. Tuttavia, Java salva gli oggetti con riferimenti diversi per differenziarli, indipendentemente dal loro contenuto. Supponiamo per esempio di istanziare due stringhe sintatticamente uguali; se non ridefinito correttamente, come da suo funzionamento, ritornerà false.\par
Dunque qui abbiamo due strade per correggere questo comportamento. Possiamo fare overriding del metodo equals() e specificare che cosa deve essere uguale per far sì che ritorni true, oppure più semplicemente ridefinire questo metodo insieme ad hashCode(). Per quest'ultima soluzione è necessario far sì che la stessa reference sia assegnata ad ogni oggetto i cui campi sono uguali ad un altro.\par
Un'altra dinamica a cui prestare attenzione è legata all'incapsulamento; generalmente, i campi dichiarati nelle superclassi, a meno che non si voglia siano condivisi a tutti i figli, sono dichiarati come privati; sarà quindi necessario utilizzare metodi getter per potervi accedere, in quanto sono gestiti come pubblici.

%

\section{Polimorfismo}
Per \textbf{polimorfismo} intendiamo un'entità che può assumere più forme; nella programmazione a oggetti si può implementare in diverse modalità. Per esempio, restando sempre nel campo dei riferimenti, diciamo che una reference di tipo $T$ può puntare ad un oggetto di tipo $S$ se e solo se $S$ è $T$ oppure una sua sottoclasse. In quest'ultimo caso, gli oggetti di tipo $T$ possono essere rimpiazzati da oggetti di tipo $S$, usando il \textbf{principio di sostituzione di Liskov}; quindi:
\begin{lstlisting}[language=Java]
	Person p;
	p = new Person();		// Corretto, T=S.
	p = new Student();		// Corretto, T sottoinsieme di S
	
	Person person = new Person("Paul");
	Student student = new Student ("Sam", 123);
	person = student;		// Sostituzione corretta, assegnato un sottotipo
	student = person;		// Errore di compilazione.
\end{lstlisting}
\noindent Nell'ultimo caso, l'errore avviene perché il compilatore effettua una ricerca ricorsiva dei metodi, partendo dalla sottoclasse fino ad arrivare a Object. Se ritorna un problema, è perché non trova il metodo chiamato in nessuna delle classi, quindi bisogna fare attenzione a rispettare i parametri da dare alle funzioni.\par
Abbiamo già menzionato il concetto di type casting; la stessa dinamica è applicabile agli oggetti, in due direzinoni:
\begin{itemize}
	\item \textbf{Upcast}: Garantito dal principio di sostituzione, type safe. Visto nello snippet di prima, dove ad un oggetto person è assegnato uno student. Si può scrivere implicitamente poiché è eseguito dal compiler in runtime.
	\item \textbf{Downcast}: Necessario esplicitarlo, non ha garanzia di essere type safe. Nel caso di prima, riguarda il caso di errore di compilazione; per far sì che sia corretto bisogna castare il tipo Student prima di person. Per evitare eventuali problemi è consigliato l'utilizzo di instanceof per controllare le superclassi.
\end{itemize}
\noindent Un altro modo per ottenere il polimorfismo, ed universalmente codice meno verboso e utilizzabile in più contesti senza che venga modificato, è dato dai tipi generici, \textbf{generics}. Questa feature si attiva usando la sintassi "<T>" al posto dei parametri. I caratteri convenzionati sono T(ype), E(lement), K(ey), V(alue). Scriveremo quindi, per esempio:
\begin{lstlisting}[language=Java]
	// Dichiarazione della classe con parametro di tipo generico.
	public class Pair <T> {
		private T first, second;
		
		// Essendo generico, può essere qualunque oggetto.
		public Pair(T first, T second) {
			this.first = first;
			this.second = second;
		}
		
		public T getFirst () { return first; }
		public T getSecond () { return second; }
	}
	
	// La classe è utilizzabile con più tipi. Cast non necessario.
	Pair <String> p = new Pair <> ("one", "two");
	Pair <Integer> q = new Pair <> (1, 2);
\end{lstlisting}
\noindent I generics funzionano perché al posto del carattere il compilatore riconosce la classe Object, ed in quanto ogni altra classe è suo sottoinsieme, si effettua un downcast tautologico.

% TODO RIPRENDI DA QUA, T16

\begin{comment}
	Chiamiamo
	questa definizione "Tipo di parametro libero". Possono essere anche legati, specificando un limite di classe superiore o inferiore.
	- Unbounded: 
	```
	public class Pair <T> { // we want to use Person here
		private T first, second;
	}
	```
	- Bounded:
	```
	// Limite superiore
	class Clazz <T extends S1 & S2 & ... & Sk>
	// Limite inferiore
	class Clazz <T super S>
	```
	
	Se T è legato, il compiler non si lagnerà per i relativi metodi dichiarati, poiché ha un limite al quale fermarsi.
	
	```
	public class Pair <T extends Person > { // we want to use Person here
		private T first , second;
		
		public Pair (T first , T second) {
			this.first = first;
			this.second = second;
		}
		
		public T getFirst () { return first.getName(); } // no error
		public T getSecond () { return second; } // T extends Person
	}
	```
	
	--- Generics e ereditarietà
	Gli iterabili C,D provenienti da una subclasse B non riconoscono come sovracclasse il padre A della sub B. Di conseguenza risultano incompatibili.
	
	Possiamo usare il parametro Wildcard '?' nel diamond per indicare un tipo generico Oggetto libero. Non differisce da una normale dichiarazione di unbounded generic T, infatti
	non sarà possibile usare metodi ad esso associati; tuttavia il vantaggio è che non richiede classi per essere usato. Puoi usarlo come parametro generale.
	Puoi tuttavia legare ? specificando limite superiore o inferiore con extends/super. In tal caso puoi usare i metodi definiti con questo tipo.
\end{comment}


%

\section{Astrazione}
Per \textbf{astrazione} intendiamo la possibilità di descrivere la forma del programma senza implementarne le funzionalità. Risulta utile sia per avere una chiara definizione della struttura delle classi, sia per, come vedremo più avanti, utilizzarle come esempio e ridurre drasticamente la dimensione del codice.\par
Introduciamo quindi il nuovo modificatore \textbf{abstract}, il quale è utilizzabile su metodi e classi; nel primo caso consente di descrivere una funzionalità della classe senza definire il suo funzionamento, ragion per cui il metodo non sarà invocabile e definibile esclusivamente in \textbf{classi astratte}. Queste ultime hanno la particolarità di avere almeno un metodo astratto, il quale rende impossibile una loro istanziazione.\par
Qui entra in gioco l'ereditarietà; per poter utilizzare classi astratte sarà necessario estenderle in sottoclassi normali con tutti i metodi definiti. L'utilità è lampante: descrivere un comportamento generale che avrà caratteristiche specifiche per ogni sottoclasse, ridefinito grazie all'override dei metodi. Questo è un paradigma di programmazione, infatti, e si chiama \textbf{Template}.
\begin{lstlisting}[language=Java]
	// Definizione della classe astratta
	public abstract class Strumento {
		public String nome;
		public String prezzo;
		// Metodo che rende la classe effettivamente astratta
		public abstract void SuonaFaDiesis();
	}
	
	// Estensione concreta di Strumento per renderla istanziabile
	public class Chitarra extends Strumento {
		@Override
		public void SuonaFaDiesis () { /* Ridefinizione */ }
	}
	
	// Estensione astratta di strumento
	public abstract class StrumentoAFiato extends Strumento { }
	
	public class Flauto extends StrumentoAFiato {
		@Override
		public void SuonaFaDiesis () { /* Ridefinizione */ }
	}
\end{lstlisting}
\noindent Se portiamo il concetto di classe astratta all'estremo, quindi ogni metodo della classe sarà definito come astratto, arriveremo a quella che è considerata un'\textbf{interfaccia} pubblica. Rappresentano la parte dell'oggetto visibile ed interagibile dall'esterno, nascondendo i procedimenti interni; sono tutte intrinsecamente definite come pubbliche e astratte.\par
Naturalmente, non essendo concrete, non possono essere definite e sono viste come tipo esclusivamente per il riferimento. Inoltre, ogni metodo ivi presente è pubblico, mentre i campi sono statici e finali. Le interfacce non si estendono, ma vengono \textbf{implementate} con l'apposita keyword \textbf{implements}, la quale svolge un lavoro analogo ad extends, permettendo di ereditare la forma dei metodi e dei campi alla sottoclasse implementativa.
\begin{lstlisting}[language=Java]
	// Dichiarazione di interfaccia
	public interface Pesabile {
		String UDM = "Kg";		// Implicitamente anche static final
		double getPeso();
	}
	
	// Implementazione di interfaccia
	public class Articolo implements Pesabile {
		private double peso;
		private String descrizione;
		
		public Articolo (String descrizione, double peso) {
			setDescrizione(descrizione);
			setPeso(peso);
		}
		
		@Override
		public double getPeso () {
			return peso;
		}
	}
\end{lstlisting}
\noindent Sebbene non si possano ereditare più classi, per una classe concreta è possibile implementare più interfacce allo stesso tempo, mentre un'interfaccia può estenderne una o multiple senza poterle implementare. Si potrebbe pensare in questi termini, di scrivere un singolo metodo per ogni interfaccia, usando il concetto di \textbf{interfaccia funzionale}.\par
Fondamentalmente risulta utile crearle per evitare dipendenze fra i metodi nelle classi che le implementano. Una classe che fa uso di un'interfaccia deve necessariamente definire ogni suo metodo, ma se questa ne ha uno solo, il problema non si pone.\newline

\noindent In precedenza abbiamo nominato come sia possibile scrivere più classi all'interno di un singolo file. Quando si dichiara una classe locale senza nome, questa è detta \textbf{anonima}; si tratta di classi istanziate ed utilizzate una singola volta, ovvero quando ne è chiamato il metodo. Questa caratteristica del linguaggio è resa possibile solo grazie all'ereditarietà, perché per essere usate, le classi anonime devono necessariamente estendere una classe oppure implementate un'interfaccia. Sono viste inoltre come \textbf{espressioni}, ed in quanto tali devono far parte di un enunciato e non possiamo specificarne un costruttore.\par
È possibile fondere questo concetto alle interfacce funzionali, permettendoci di ottenere ciò che è conosciuto come \textbf{funzione lambda}. La loro ragion d'essere è rendere il codice più compatto, leggibile ed indipendente. Hanno sintassi: \begin{center}
	listaDiParametri -> bloccoDiCodice
\end{center}
\begin{lstlisting}[language=Java]
	// Istanziazione di singleInc, come gia' visto.
	SingleInterface singleInc = new SingleInterface () {
		@Override
		public int singleMethod(int param) { return param + 1; }
	};
	
	// Utilizzo della lambda. Risparmiate ben tre righe.
	SingleInterface singleDec = param -> param-1;
	
	System.out.println(singleInc.singleMethod(3)); // Output: 4
	System.out.println(singleDec.singleMethod(3)); // Output: 2
\end{lstlisting}
\noindent Notare che in quanto classi anonime, le lambda erediteranno le loro dinamiche. Inoltre, i parametri che può accettare possono andare da zero a molti, mentre il corpo della funzione è necessariamente una sola espressione oppure un blocco di codice.\par
Un ultima cosa utile, ma non necessariamente sicura o consigliata è la possibilità di passare ai metodi una variabile argomenti, detta \textbf{varargs}; si traduce nel passaggio di un array e può aiutare a ridurre la dimensione del codice. La sintassi è: \begin{center}
	nomeMetodo(tipo... nomeParametro)
\end{center}
\begin{lstlisting}[language=Java]
	public interface SingleInterface { int singleMethod(int... params); }
	
	// Utilizzo di varargs con un normale metodo, classe anonima.
	SingleInterface singleInc = new SingleInterface() {
		@Override
		public int singleMethod (int... params) { return params [0] + 1; }
	};
	
	// Utilizzo di varargs con una lambda
	SingleInterface singleDec = params -> params [0]-1;

	System.out.println(singleInc.singleMethod(3, 4, 5)); // Output: 4
	System.out.println(singleDec.singleMethod(3, 2)); // Output: 2
\end{lstlisting}