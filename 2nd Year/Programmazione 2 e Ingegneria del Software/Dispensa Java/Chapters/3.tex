\section{Incapsulamento}
L'incapsulamento è un concetto che ha origine nelle modalità di interazione nel mondo reale. Così come per interagire con una persona si usa la voce per ottenere informazioni specifiche, allo stesso modo gli oggetti comunicano con interfacce apposite al fine di ritornare dati. Questa filosofia si ottiene controllando l'accesso ai dati tramite le keyword dei modificatori di accesso. Più precisamente, bisogna:
\begin{enumerate}
	\item Dichiarare gli attributi di una classe come \textbf{privati}, per renderli inaccessibili ad altre classi al di fuori di questa.
	\item Creare dei metodi \textbf{pubblici} per accedere, modificare e riportare gli attributi privati in maniera controllata, talvolta con dei controlli per assicurarsi che i dati siano presentati con certe caratteristiche. Questi metodi si chiamano \textbf{setter}, per assegnare il dato all'oggetto, e \textbf{getter}, per accedere al dato dell'oggetto.
\end{enumerate}
\begin{lstlisting}[language=Java]
	public class Date {
		private int day, month, year;
		
		// Metodo setter per garantire che giorno sia un valore corretto
		public void setDay (int g) {
			if (j >= 1 && j<= 31) giorno = g;
			else System.out.println("Invalid day");
		}
		
		// Metodo getter per ritornare il valore in sicurezza
		public int getDay () { return day; }
		
		public void setMonth (int m) {
			if (m <= 1 && m <= 12) month = m;
			else System.out.println("Invalid month");
		}
		
		public int getMonth () { return month; }
	
		public void setYear (int y) {
			if (y <= 0) year = y;
			else System.out.println("Invalid year");
		}
		
		public int getYear () { return year; }
	}
\end{lstlisting}

%

\section{Ereditarietà}
- Definizione di classi per estensione, ereditando campi e metodi
- Relazione superclasse/sottoclasse e concatenazione dei costruttori da sottoclasse a superclasse con super()
- Gerarchia di classe
- Ereditarietà singola e multipla

%

\section{Polimorfismo}
- Ridefinizione o aggiunta di metodi

%

\section{Astrazione}
- Interfaccia pubblica di una classe
- Interfacce e relativo utilizzo
- Metodi e classi abstract
- Aliasing fra variabili e rischi
- Classi anonime, espressioni lambda, interfacce funzionali
- Parametri varargs, tipi generici, libreria Comparable<T>. Vincoli sulle variabili di tipo


\begin{comment}
	Da decidersi:
	- Javadoc
	- Late binding e class tag degli oggetti
	- Eccezioni implicite ed esplicite (throw/catch), gerarchia eccezioni, controllate/non controllate. Throws per metodi, definizione di classi di eccezione
	- Race condition, Deadlock, synchronized
	- Stream lazy
\end{comment}