\section{Modello di Von Neumann e Unità funzionali del calcolatore}
Il \textbf{Modello di Von Neumann} è un'architettura composta da tre componenti principali interconnesse mediante un dispositivo detto \textbf{BUS}\footnote{Flusso di bits che rende possibile la comunicazione fra le varie componenti}. Si tratta del modello sul quale si basano tutte le architetture dei calcolatori. Le sue parti sono:\newline

\begin{minipage}{0.475\textwidth}
	\includegraphics[width=1\linewidth]{Images/VonNeumannArch.png}
	\label{fig:VonNeumannArch}
\end{minipage}
\vspace{0.02\textwidth}
\begin{minipage}{0.475\textwidth}
	\begin{itemize}
		\item \textbf{Processore}: Atto all'elaborazione dei dati.
		\item \textbf{Memoria}: Atta al salvataggio dei dati.
		\item \textbf{Dispositivi I/O}: Periferiche varie come microfoni o tastiere.
	\end{itemize}
\end{minipage}
\noindent Più nello specifico, un calcolatore elabora i dati grazie all'ausilio delle seguenti tre componenti, ognuna indipendente dall'altra:
\begin{itemize}
	\item \textbf{I/O}: Unità di ingresso ed uscita.
	\item \textbf{ALU}: Unità aritmetico-logica.
	\item \textbf{CU}: Control Unit, che compone processore e memoria.
\end{itemize}
\noindent Le prime due lavorano sotto supervisione e controllo della \textbf{CU}. L'unità di input riceve informazioni in forma codificata da operatori o periferiche, le quali saranno elaborate dalla \textbf{ALU} per effettuare calcoli, eventualmente salvando in memoria i risultati. Quanto eseguito verrà inviato all'unità di output, la quale ritornerà il tutto.\par
Le informazioni manipolate sono categorizzate in \textbf{istruzioni} e \textbf{dati}; le prime sono comandi dati alla macchina, direttamente interpretabili da essa, mentre i secondi sono le informazioni che vengono manipolate. Una lista di istruzioni compone il \textbf{programma}, il quale potrà svolgere algoritmi elaborando i dati. Se in esecuzione, si troverà sempre in memoria, a meno che non venga dato un comando di interruzione.\newline

\noindent L'ambiente di lavoro del corso sarà la CPU Intel 80x86, con la particolarità di utilizzare lo stesso linguaggio del microprocessore: \textbf{Assembly}. L'insieme che compone le istruzioni scritte in tale lingua leggibili dal microprocessore si dice \textbf{ISA}, Instruction Set Architecture, ed è letto da un \textbf{assemblatore}, il quale provvederà a tradurlo in codice oggetto.
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{Images/CPUArch.png}
	\caption{Architettura di una CPU}
	\label{fig:CPUArch}
\end{figure}
\noindent Analizziamo ora le microcomponenti della CPU non ancora viste:
\begin{itemize}
	\item \textbf{Componenti generali}:
	\begin{itemize}
		\item \textbf{Bus Dati}: Consente di trasportare i dati fra le varie componenti.
		\item \textbf{Bus Indirizzi}: Comunica gli indirizzi di memoria delle informazioni.
		\item \textbf{Bus di Controllo}: Invia i segnali di controllo fra le varie componenti.
		\item \textbf{Memory Address Register}: Tiene in memoria e fornisce gli indirizzi dei dati da manipolare.
		\item \textbf{Memory Data Register}: Salva temporaneamente i dati da o per la CPU.
	\end{itemize}
	\item \textbf{Componenti della control unit}:
	\begin{itemize}
		\item \textbf{Instruction Register}: Contiene gli identificativi delle istruzioni.
		\item \textbf{Program Counter}: Contiene gli indirizzi delle stesse.
		\item \textbf{Program Status Word}; Insieme di flags che, in stretta collaborazione con la ALU, indicano lo stato dei diversi risultati di operazioni matematiche. Si modifica ad ogni singola operazione.
	\end{itemize}
\end{itemize}
\noindent Ora che sappiamo da cosa è composta, è il momento di chiederci come funziona questa CPU. Ci è possibile descrivere tale processo mediante una FSM a tre stati, chiamati \textbf{Fetch}, \textbf{Decode} ed \textbf{Execution}.\par
Il primo rappresenta la ricezione delle informazioni. Ottiene i dati dall'\textbf{MDR}, memory data register, per poi passare tutto all'\textbf{IR}, instruction register con il bus dati. Nel frattempo, il program counter aumenterà di 1 ad ogni istruzione ricevuta.\par
Il secondo stato è la fase di decodifica delle istruzioni; tramite l'ISA della macchina, si indirizzano opportunamente i dati che verranno poi elaborati.\par
Il terzo ed ultimo stato è infatti quello dell'esecuzione delle istruzioni decodificate.\newline
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{Images/FetDecExe.png}
	\caption{Macchina a stati della CPU}
	\label{fig:FDE}
\end{figure}

\noindent L'ISA, come si può facilmente dedurre, non è uguale per ogni singolo calcolatore, tuttavia presenta sempre lo stesso scheletro, composto da:
\begin{itemize}
	\item \textbf{OPcode}: Il codice operazione. Comunica quante istruzioni possono essere registrate, ma soprattutto quale sta venendo effettuata.
	\item \textbf{Source Address}: L'indirizzo dal quale ottenere le informazioni.
	\item \textbf{Destination Address}: L'indirizzo nel quale verranno salvate le informazioni.
\end{itemize}
\noindent La modalità di scambio e trasmissione dati si chiama \textbf{indirizzamento}, i cui tipi sono discussi più nello specifico nella sezione relativa ad Assembly.

%

\section{Architettura CPU RISC-V}
Come precedentemente menzionato, le CPU organizzano il lavoro del calcolatore, e più nello specifico ciò avviene grazie ad un ciclo di \textbf{fetch}, \textbf{decode} ed \textbf{execution}. Segue i passi:
\begin{enumerate}
	\item Il program counter si modifica per puntare all'istruzione successiva.
	\item Viene determinato il tipo dell'istruzione letta.
	\item Se l'istruzione usa una word in memoria, si determina dove essa si trovi.
	\item Se necessario, si carica la word in un registro della CPU.
	\item Esecuzione dell'istruzione.
	\item Ripeti il passo 1.
\end{enumerate}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{Images/ControlUnit_simple.png}
	\caption{Architettura semplificata della control unit}
	\label{fig:CU_simple}
\end{figure}
\noindent A partire da questo disegno, è necessario andare più nel dettaglio con alcune componenti. Per esempio, è importante notare i due adder in alto. Questi consentono di spostarsi fra le varie istruzioni; infatti il primo all'estrema sinistra è quello che aggiorna il program counter sommandogli $4B$, spostandolo all'istruzione successiva, mentre il secondo adder è utile per le istruzioni di salto. Ottenuto il nuovo indirizzo, il program counter verrà aggiornato.\par
Bisogna inoltre tenere a mente che i dati da passare alla ALU sono contenuti nei \textbf{registri}; in base al segnale dato dalla control unit, si effettuerà un'operazione specifica. Detto ciò, possiamo elaborare sul ciclo di elaborazione informazioni:
\begin{itemize}
	\item \textbf{Fetch}, la selezione della parola corrispondente all'istruzione da eseguire. Qui il program counter fornisce l'indirizzo di memoria in cui si trova la prossima istruzione. Questo valore è ottenuto da una memoria read only chiamata \textbf{memoria delle istruzioni}.
	\item \textbf{Decode}, la decodifica dell'istruzione in codice oggetto. In primo luogo la ALU decodifica le istruzioni ricevute in base al valore del program counter e, se necessario, verranno caricati gli operandi dalla \textbf{memoria dei dati}.
	\item \textbf{Execution}, l'esecuzione dell'istruzione. Qui si possono effettuare processi diversi, come:
	\begin{itemize}
		\item Eseguire un calcolo con la ALU.
		\item Elaborare il contenuto degli operandi e determinare un indirizzo di memoria.
		\item Eseguire un confronto per effettuare dei salti.
	\end{itemize}
\end{itemize}
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth]{Images/ControlUnit1.png}
	\caption{Architettura della control unit}
	\label{fig:CU1}
\end{figure}
\noindent Notare adesso nella nuova figura con aggiunta la \textbf{control unit} che i segnali dei due adder vanno in un mux, per capire quale utilizzare in base al segnale branch, ovvero di salto, usato come controllo. Quest'ultimo è dato da una porta AND che prende:
\begin{itemize}
	\item Il risultato della condizione per il jump (zero).
	\item Il segnale di richiesta di jump (uscito dalla CU).
\end{itemize}
\noindent Se e solo se entrambi i bits sono veri, si va a saltare all'indirizzo richiesto, ed in tal caso il primo parametro è dato dal PC, mentre il secondo è un pezzo corrispondente al path saltato.\par
Un altro compito della control unit è l'invio di segnali \textbf{memoryRead},  \textbf{memoryWrite} e \textbf{registerWrite}, i quali consentono di leggere e scrivere valori in memoria.\par
Notare inoltre il multiplexer posto fra la ALU ed il blocco centrale; è necessario per scegliere il luogo da dove prendere l'operando. È possibile ottenerlo dalla memoria oppure direttamente dall'input.\newline

\noindent Adesso invece andiamo a vedere nello specifico il comportamento del datapath in base all'istruzione data. Ne abbiamo di quattro tipi:
\begin{itemize}
	\item \textbf{Type-R}: Istruzioni aritmetico-logiche.\par
	I registri \textbf{rs1} e \textbf{rs2} presentano il numero dei registri sorgenti ed \textbf{rd} contiene il numero del registro di destinazione. L'operazione da eseguire sta nei campi \textbf{func3} e \textbf{func7} ed è letto dalla control unit per comunicare i segnali adatti alla ALU.
	\item \textbf{Type-L}: Istruzioni di caricamento. Necessita di memoria dati e componente per estensione del segno.\par 
	Si attiva con il segnale \textbf{memRead} a valore vero. Qui \textbf{rs1} è il registro base il cui contenuto è sommato al campo immediato di 12b per ottenere l'indirizzo del dato in memoria. Il campo \textbf{rd} è il registro destinazione per il valore letto.
	\item \textbf{Type-S}: Istruzioni di salvataggio. Necessita di memoria dati e componente per estensione del segno.\par 
	Si attiva con il segnale \textbf{memWrite} a valore vero. Qui \textbf{rs1} è il registro base il cui contenuto è sommato al campo immediato di 12b per ottenere l'indirizzo del dato in memoria. Il campo \textbf{rs2} è il registro sorgente il cui valore è poi copiato in memoria.
	\item \textbf{Type-SB}: Istruzioni di salto.\par
	\textbf{rs1} e \textbf{rs2} sono confrontati. Il campo immediato di 12b è preso, il suo bit di segno viene esteso, shiftato a sinistra di una posizione e sommato al program counter per calcolare l'indirizzo di destinazione del salto.
\end{itemize}
% TODO INSERISCI ControlUnit_riscV.png, è l'immagine del datapath completo.
\begin{eg}
	\textbf{Istruzione [sub x4, x5, x6]}
	\begin{enumerate}
		\item Il PC dà l'indirizzo dell'istruzione e viene incrementato di $4B$.
		\item L'istruzione è decodificata, viene riconosciuto il tipo-R. Ciò è indicato dal Codop, che è inviato alla CU.
		\item In base al Codop, la CU imposta i segnali: \textbf{regWrite = 1}, perché scriverà in x4, \textbf{ALUSrc = 0}, perché gli operandi vengono dai registri, \textbf{memWrite = 0}, \textbf{memRead = 0}, \textbf{memToReg = 0}, perché non c'è accesso alla memoria.
		\item La CU legge \textbf{func3=0b000} e \textbf{func7=0b0100000}, determinando che l'operazione è una sottrazione.
		\item La ALU calcola $x4 = x5-x6$.
		\item Se il risultato è $0$, il segnale \textbf{Zero} sarà vero, ed il primo è scritto nel register file.
		\item Adesso $x4$ contiene il valore $x5-x6$.
	\end{enumerate}
\end{eg}
\begin{eg}
	\textbf{Istruzione [and x7, x8, x9]}
	\begin{enumerate}
		\item PC dà l'indirizzo dell'istruzione e si incrementa di $4B$.
		\item Il decoder la riconosce come Type-R.
		\item La CU imposta: regWrite = 1, ALUSrc = 0, memWrite = 0, memRead = 0, memToReg = 0.
		\item La ALU ottiene \textbf{func3=0b111} e \textbf{func7=0b0000000}, selezionando l'operazione logicalAND. Esegue quindi $x7 = x8 \land x9$.
		\item Scrive il risultato nel register file.
		\item $x7$ contiene il risultato di $x8 \land x9$.
	\end{enumerate}
\end{eg}
\begin{eg}
	\textbf{Istruzione [lw x4, 16(x5)]}
	\begin{enumerate}
		\item PC dà l'indirizzo dell'istruzione e avanza di $4B$.
		\item L'istruzione decodificata è type-L, LOAD.
		\item $x5$ viene letto dal register file per ottenere l'indirizzo base.
		\item L'offset $16$ viene estratto e inviato alla ALU, che calcola l'indirizzo effettivo eseguendo $x5+16$.
		\item L'indirizzo risultante è inviato alla memoria dati, che restituisce il valore ivi memorizzato.
		\item Il valore letto va nel mux che riceve anche memToReg=1 e regWrite=1.
		\item Il valore è ora scritto in $x4$, che conterrà infatti il valore memorizzato all'indirizzo $x5+16$.
	\end{enumerate}
\end{eg}
\begin{eg}
	Inserisci esempio istruzione di salto.
\end{eg}
\noindent Un'ultima particolarità di cui tener conto è il quantitativo di bits usati per un'operazione. Usiamo load come esempio; avremo:
\begin{itemize}
	\item \textbf{lw}: Load word.
	\item \textbf{lh}: Load half-word.
	\item \textbf{lb}: Load byte.
	\item \textbf{l*u}: Load unsigned, con $* \in \{w, h, b\}$
\end{itemize}

%

\section{Metodi di I/O, Segnale Interrupt}

%

\section{Direct Memory Access, BUS e Arbitraggio}




Senso della memoria cache:
- Il bus riceve segnali elettromagnetici e per far sì che continui a funzionare senza essere danneggiato deve necessariamente essere esteso con una certa dimensione. Tuttavia, ciò rallenta il processo di scambio dati.
Se invece i dati sono già in CPU, del bus non ce n'è bisogno ed il fetch è pressoché istantaneo. Meglio, no? È veloce. Se applichiamo questo concetto alle istruzioni noterai che avrai due tipi di memorie; una per i dati, ed una per le istruzioni. Quando la roba è in cache, ci accede in 1 clock tick.

%

\section{Stati di un processo}

%

\section{Pila e gestione Interrupt}

%

\section{Tipi di Memoria RAM}
Static RAM, Dynamic RAM, Banchi di memoria ed esercizi.

%

\section{Caratteristiche delle memorie con relativa gerarchia}

%

\section{Memoria Cache e Virtuale}

%

\section{Pipelining}

%

\section{Modello CISC e RISC}

%

\section{Architetture parallele}