La domanda principale di questo capitolo è "Come realizzare un sistema digitale?" Ebbene, è necessario un modello apposito che consentirà di rappresentare appropriatamente la sua struttura. Per far ciò useremo l'\textbf{algebra di Boole}; uno spazio ad $n$ dimensioni misurate in base all'alfabeto che voglio dare allo spazio. Qui sono presenti solo due valori come in base binaria: $0$ e $1$.\par 
Secondo Boole, se si definisce una funzione che genera valori in un altro spazio, generalmente scritta $f(B^n) -> B^m$, questa potrà essere rappresentata tramite gli operatori elementari; in pratica ci puoi fare qualunque cosa.\par
Utilizzando questo spazio è possibile passare da una scrittura ambigua ad una formale, chiara per quelli che saranno i nostri scopi; la rappresentazione dei sistemi avviene infatti tramite le tabelle di verità, che mostrano le funzioni booleane.\newline
\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{Images/booleanFunction.png}
	\caption{Funzione booleana XNOR}
	\label{fig:booleanFunction}
\end{figure}
\noindent Nella tabella di verità vengono definiti:
\begin{itemize}
	\item \textbf{Onset}: L'insieme dei punti dello spazio di ingresso dove la funzione vale 1. Gli elementi si dicono \textbf{mintermini}.
	\item \textbf{Offset}: L'insieme dei punti dello spazio di ingresso dove la funzione vale 0. Gli elementi si dicono \textbf{maxtermini}.
\end{itemize}
\noindent L'unione di questi due insiemi è complementare, poiché rappresentano tutto lo spazio usato dalla funzione. Inoltre, per mettere in relazione i bit con gli operatori si utilizzano le seguenti espressioni: \[m_3 = a \times b, m_0 = !a \times !b\]
\noindent In tal merito, definiamo \textbf{letterale} una qualunque coppia \{variabile, Valore\} ed è l'unità di misura usata per definire la complessità di un circuito. Infine, la funzione in output si scrive attraverso una somma di prodotti o somma di min/maxtermini, per esempio: $O = abc + !ac + b!c$ e avremo una complessità di 7 letterali.

\section{Realizzazione di porte logiche}
Le porte logiche e di conseguenza qualunque circuito elettronico sono governati dal flusso di elettricità gestito dai \textbf{transistors}; interruttori comandati. Nella tecnologia \textbf{CMOS} (Complementary Metal Oxide Semiconductor) sono implementati solo due tipi:
\begin{itemize}
	\item \textbf{Interruttore N}: Se riceve corrente, conduce l'elettricità.
	\item \textbf{Interruttore P}: Se riceve corrente, ferma il flusso.
\end{itemize}
\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{Images/transistorTypes.png}
	\caption{Tipi di transistors}
	\label{fig:transistorTypes}
\end{figure}
Per usare termini corretti, quando un transistor è chiuso e scorre la corrente si dice che è in \textbf{conduzione}, mentre se è aperto e la corrente è bloccata diciamo che c'è un segnale di \textbf{interdizione}.\par 
Di base i circuiti vanno letti da sinistra a destra, e grazie ai due interruttori appena visti è possibile creare le porte logiche elementari \textbf{AND, OR, NOT, NAND, NOR, XOR, XNOR}. Adesso abbiamo tutti gli strumenti per la creazione di un circuito elettronico. Ciò non significa tuttavia che possiamo buttarci senza cognizione di causa; ragion per cui bisognerà ragionare sui costi e le parti effettivamente necessarie al processo di realizzazione. Il nostro scopo da adesso diventa l'\textbf{ottimizzazione} dei nostri progetti.
\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{Images/logicGates.png}
	\caption{Porte logiche elementari}
	\label{fig:logicGates}
\end{figure}

%

\section{Minimizzazione a due livelli}
Non esiste un solo modo per ottimizzare un circuito, bensì più tecniche, tutte con la loro ragion d'essere in base ai nostri scopi. Una prima semplice regola, per esempio è l'\textbf{assorbimento}, da utilizzare assieme all'algebra di Boole. Bisogna innanzitutto tenere a mente queste proprietà:
\begin{itemize}
	\item Identità: $1\times x = x$, $0+x = x$
	\item Elemento nullo: $0\times x = 0$, $1+x = 1$
	\item Idempotenza: $x\times x = x$, $x+x=x$
	\item Inverso: $x\times \overline{x} = 0$, $x+\overline{x} = 1$
\end{itemize}
\noindent Valgono anche le proprietà associative, commutative e distributive. Procediamo col dare la definizione della regola:
\begin{definition}
	\textbf{Regola dell'assorbimento}\par 
	\noindent Sia una funzione booleana scritta in somma di prodotti; se due di questi sono a distanza di Hamming 1, è possibile sommare le parti inverse ed ottenere il valore 1, riducendoi letterali e quindi la complessità della funzione.
	\[x(x+y) = x, x+(xy) = x\]
\end{definition}
\begin{eg}
	Si ottimizzi la seguente funzione in somma di prodotti: \[O = \overline{xyz}+ \overline{xy}z + x\overline{yz} + x\overline{y}z + xyz\]
	\noindent Utilizziamo l'assorbimento; per prima cosa bisogna vedere se sono presenti termini a distanza di Hamming 1 per semplificarli; ripetere il processo fin quando non è più possibile.
	\begin{equation}
		\begin{split}
			O &= \overline{xyz}+ \overline{xy}z + x\overline{yz} + x\overline{y}z + xyz\\
			  &= \overline{xy}(\overline{z}+z) + \overline{yz}(x+\overline{x}) + \overline{y}z(x+\overline{x}) + x\overline{y}(\overline{z}+z) + xz(\overline{y}+y)\\
			  &= \overline{xy} + \overline{yz} + \overline{y}z + x\overline{y} + xz\\
			  &= \overline{y} + \overline{y} + xz\\
			  &= \overline{y} + xz
		\end{split}
	\end{equation}
\end{eg}
\noindent In parole molto povere, bisogna vedere uno per uno tutti i termini che presentano un solo bit di differenza fra di loro, ovvero a \textbf{distanza di Hamming} 1, e rimuovere le due parti inverse, poiché equivarranno ad 1.
\begin{figure}[h]
	\centering
	\includegraphics[width=8cm]{Images/hammingDistance.png}
	\caption{Cubo delle distanze fra codifiche}
	\label{fig:hammingDistance}
\end{figure}
\noindent Nello svolgimento dell'ottimizzazione, chiameremo i termini che non è più possibile ridurre come \textbf{implicanti primi}; dove è vero che li vogliamo, è possibile che più implicanti primi coprano lo stesso mintermine, creando una ripetizione inutile. Ci è quindi necessario cercare gli \textbf{implicanti primi essenziali}, ovvero un implicante che tocca un mintermine non raggiunto dagli altri.\par 
Subentra di conseguenza la questione della \textbf{copertura minima}, ovvero il problema di trovare il numero minimo di implicanti necessari per coprire ogni mintermine; per lavorare useremo i due metodi nelle prossime sezioni.

%

\subsection{Mappa di Karnaugh}
Da me soprannominato "Il Sarrus dell'ottimizzazione", è un algoritmo utilizzabile con funzioni $f(B^3)$ o massimo per $f(B^4)$. Servirà prendere il cubo delle distanze visto prima ed immaginare di piallarlo. Usciranno le celle corrispondenti agli spigoli del solido.\par 
Una particolarità è che il cubo deve essere visto come se fosse impossibile andare out of bounds; quindi una volta superato un lato estremo, ci si trova subito dopo in quello opposto, esattamente come in Pacman.
\begin{figure}[h]
	\centering
	\includegraphics[width=8cm]{Images/karnaugh_2b.png}
	\caption{Mappa di Karnaugh}
	\label{fig:karnaugh_2b}
\end{figure}
\noindent Le celle adiacenti sono quelle a distanza di Hamming 1 e la funzione ottimizzata è quella di prima, con risultato $O = \overline{y}+xz$.

%

\subsection{Algoritmo di Quine Mc-Cluskey}
Trattasi del Laplace di questa materia, sarà l'algoritmo che useremo per l'ottimizzazione dei circuiti combinatori. Può essere utilizzato con ogni tipo di funzione, ma aumenta di complessità in base a quante entrate presenta. Generalmente, segue i passaggi:
\begin{enumerate}
	\item Partendo dalla tabella di verità completa, prendere i suoi mintermini e ordinarli in base al numero di $1$ contenuti nella combinazione di ingresso.
	\item Confrontare ogni configurazione con tutte quelle del gruppo successivo. Se presenta distanza di Hamming a valore 1 (più semplicemente, se le due combinazioni di entrate sono uguali tranne per un input), inserire un \textbf{don't care} dove gli inputs differiscono.
	\item Ottenuta la tabella ridotta, ripetere il punto 2 fin quando non è più possibile ridurre i mintermini. Fatto ciò, abbiamo ottenuto gli implicanti primi.
	\item Creare una seconda tabella indicando sulle $y$ i mintermini e sulle $x$ le entrate. Lo scopo è trovare quei mintermini sufficienti per coprire tutti gli inputs, saranno gli implicanti primi essenziali.
	\item Scrivere la soluzione in somma di prodotti. Finito.
\end{enumerate}
\noindent Metodo decisamente macchinoso, che tuttavia permette di ottenere tramite semplici passaggi la funzione ottima. Segue immagine per evidenziare il caso base.
%TODO INSERISCI ESERCIZIO SU QUINE MCCLUSKEY COMPLETAMENTE SPECIFICATO

%

\subsection{Funzioni parzialmente specificate}
Quine Mc-Cluskey è versatile. È possibile utilizzarlo anche con funzioni, le quali hanno combinazioni risultanti come don't cares. L'algoritmo non cambia molto, bisognerà solamente considerare il DC-set come altri mintermini per poi ignorarlo nella tabella finale.
%TODO INSERISCI ESERCIZIO SU QUINE MCCLUSKEY PARZIALMENTE SPECIFICATO

%

\section{Dispositivi programmabili}
I dispositivi programmabili sono componenti hardware dotati di porte \textbf{PROM}, programmable read only memory. La loro implementazione comporta alcune conseguenze:
\begin{itemize}
	\item Essendo il circuito programmabile, è modificabile anche dopo la sua produzione, quindi, in caso di necessità, si risparmierà sui materiali.
	\item Eventuali bug presenti nel circuito potranno essere facilmente risolti grazie a questa flessibilità.
	\item La logica di programmazione copre necessariamente spazio nell'area; verrà sempre utilizzata, richiedendo energia.
	\item Risulta tendenzialmente più lento rispetto ad un dispositivo dedicato.
\end{itemize}
\noindent Una prima evoluzione dei circuiti PROM sono i \textbf{PLA}, i programmable logic array, con due livelli di porte logiche.
%TODO Inserisci esempio di rappresentazione in PLA
\noindent Col tempo si evolsero in \textbf{CPLD}, complex programmable logic devices, un'interconnessione di più circuiti PLA su una scheda di silicio.
%TODO Inserisci esempio di rappresentazione in CPLD
\noindent Dopodiché nacquero gli \textbf{FPGA}, field programmable gate array, che sono i dispositivi programmabili odierni. Sono composti da vari CPLD.
%TODO Inserisci esempio di rappresentazione in FPGA
\noindent Infine abbiamo gli \textbf{SoC}, system on chip, l'evoluzione più recente utilizzata su vasta scala. Si tratta di una FPGA controllata da una CPU.
%TODO Inserisci esempio di rappresentazione in SoC

%

\section{Sintesi combinatoria multilivello}
Finora è stato visto come sintetizzare circuiti combinatori ad un massimo di due livelli; è tuttavia possibile espandere il concetto ad $n$ livelli, accettando un compromesso di otterere soluzioni approssimate, tramite tecniche euristiche. In tal merito, introduciamo il concetto di \textbf{ritardo}, il valore tempo impiegato per ottenere gli outputs da un circuito, il quale è dato dal \textbf{cammino critico}, il percorso più lungo che la corrente attraversa dall'entrata all'uscita.
%TODO Inserisci immagine esempio di ritardo con unità di tempo t
\noindent Le tecniche sovramenzionate procedono su due passi principali:
\begin{enumerate}
	\item Ottimizzazione eseguita ignorando i vincoli implementativi, come quelli imposti dalla libreria tecnologica o al fanin/fanout.
	\item Raffinamento del precedente risultato in base ai vincoli implementativi.
\end{enumerate}
\noindent Non sarà un risultato ottimo come lo darebbe la fattorizzazione, tuttavia riduce il carico computazionale. Per lavorarci, introduciamo i relativi \textbf{modelli di rappresentazione} e le \textbf{trasformazioni} con le quali si andrà ad operare.\par 
La struttura di un circuito può essere rappresentata tramite una \textbf{rete logica}, una interconnessione di nodi associati a funzioni booleane ad una sola uscita, l'ultime chiamate \textbf{funzioni scalari}. Questa collega i comportamenti delle funzioni dei nodi e viene rappresentata tramite \textbf{grafi orientati aciclici}, "DAG" $G(V,E)$, dove;
\begin{itemize}
	\item $V$ è l'insieme dei nodi, diviso in $V^I$ (nodi d'ingresso), $V^O$, (nodi d'uscita) $V^G$, (nodi interni a cui è associata una funzione scalare)
	\item $E$ è l'insieme dei lati.
	\item Ad ogni nodo si associa una variabile temporanea.
\end{itemize}
% TODO INSERISCI ESEMPIO DAG
\noindent Bisognerà quindi capire su quale parte operare per ottimizzare; il ritardo, riducendo i tempi di esecuzione, o l'area, riducendo il carico computazionale? Tendenzialmente si cerca di trovare un equilibrio fra i due e gli algoritmi o \textbf{scripts} usati si dividono in algoritmi di \textbf{ottimizzazione}, che riducono il livello di complessità, e di \textbf{ristrutturazione}, i quali restaurano il circuito ad uno stato più complesso ma meno carico. Si useranno esclusivamente strumenti automatici.

%

\section{Mapping tecnologico}
Il \textbf{mapping tecnologico} è il problema di implementazione dei circuiti sequenziali mediante le porte logiche di una data libreria tecnologica.\par 
Una volta completato il processo di minimizzazione tramite gli scripts, si otterrà un risultato in somma di prodotti, rappresentativo della minima realizzazione teorica. Ci occuperemo ora di mapparlo su una libreria tecnologica con lo scopo di renderlo realizzabile per la specifica architettura.\par 
L'algoritmo alla base del processo è detto \textbf{tree-mapping}, una dispiegazione dei nodi come se fosse un grafico ad albero. L'unico limite risulta, qunidi, la necessità di non avere nodi predecessori. Il circuito con la rispettiva libreria, ambo convertiti in grafici albero, potranno poi essere scritti sulle seguenti architetture:
\begin{itemize}
	\item \textbf{ASIC}: Il cui processo è diviso in due parti:
	\begin{enumerate}
		\item \textbf{Placing}: Posizionamento delle celle nella scheda.
		\item \textbf{Routing}: Collegamento delle celle fra loro.
	\end{enumerate}
	\item \textbf{FPGA}: Il cui processo di placing corrisponde alla programmazione delle celle, le quali hanno egual dimensione e capacità.
\end{itemize}