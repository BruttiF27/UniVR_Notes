% TODO ----- Riformulare l'intero capitolo

\section{Introduzione}
R è linguaggio di programmazione. Viene utilizzato per l'analisi statistica dei dati e la loro visualizzazione, statistica descrittiva, machine learning, manipolazione dei dati, datamining e anche nella ricerca scientifica.\par
Basato su un codice open-source, la sua sintassi è estremamente flessibile e a tratti simile a C. È inoltre un linguaggio diviso in pacchetti, ovvero insiemi di funzioni create da altri utenti. In particolare vedremo:
\begin{itemize}
	\item \textbf{ggplot2}; usato per la creazione dei grafici.
	\item \textbf{dplyr}; usato per la manipolazione dei dati.
\end{itemize}
I files con dominio ".R" sono detti \textbf{R-Scripts}; infatti ciò che andremo a scrivere e far elaborare dal software sono fondamentalmente dei testbench per ritornare determinati risultati o comportamenti. Per lavorare su di essi è necessario l'uso del terminale, e dove è possibile utilizzare l'interfaccia di R innata, è consigliato, e così faremo nel corso, utilizzare l'ambiente di sviluppo \textbf{R Studio}. Spiegare un IDE esula dallo scopo della dispensa, arrangiati e leggi le relative documentazioni.\par
Installato R Studio avremo davanti il terminale, l'ambiente dei dati e una terza interfaccia variabile per i grafici, manuale e tant'altro. Abbiamo nominato dei pacchetti con i quali andremo a lavorare; questi devono essere installati con il seguente comando:
\begin{verbatim}
	> install.package("nomePacchetto")
\end{verbatim}
Prima di iniziare, tengo a ricordare che un codice scritto bene è nella maggior parte del tempo autoesplicativo e l'utilizzo dei commenti è richiesto solamente in casi dove sarebbe impossibile arrivare al senso da soli. Detto ciò:
\begin{verbatim}
	# Questo è un commento
\end{verbatim}
\noindent Ho utilizzato due scritture diverse. Nel corso della sezione sarà considerata scrittura al terminale qualunque cosa vada dopo il carattere ">", altrimenti è uno script su file .R. Ora che abbiamo tutto pronto possiamo iniziare a lavorare col linguaggio.

%

\section{Variabili, operatori e costrutti}
Partiamo da dei semplici outputs. R ci consente di stampare a video direttamente stringhe, numeri ed operazioni senza che esse vengano contenute in una variabile:
\begin{verbatim}
	> "Hello World!" # Stampa la stringa Hello World!
	> 27 # Stampa il numero 27
	> 5 + 5 # Stampa il numero 10
\end{verbatim}
\noindent La dichiarazione di variabili è molto semplice; bisogna solamente tenere a mente tre restrizioni del linguaggio:
\begin{itemize}
	\item R è case-sensitive. Quindi "Palle" $\neq$ "palle".
	\item Le variabili dichiarate non possono iniziare con un numero.
	\item Le variabili dichiarate non possono essere dichiarate con un nome uguale ad una parola chiave.
\end{itemize}
\noindent Chiarito ciò, è possibile dichiararle come segue:
\begin{verbatim}
	> A <- 1+1		# Dichiaro A col valore 2
	> A				# Stampo la variabile A	a video
	> A <- NULL		# Rendo la variabile vuota
	> remove(A)		# Rimuove la variabile dall'ambiente
\end{verbatim}
\noindent R supporta i seguenti tipi di dato, assegnati automaticamente all'inizializzazione della variabile:
\begin{itemize}
	\item Numerico, come $[2, 10, 3.75]$. Considera quindi anche i razionali.
	\item Intero, come $[10L, 32L, 99L]$. La lettera L è necessaria per dichiarare il numero come intero.
	\item Complesso, come $[2i, 4i, 28i]$. La i indica l'unità immaginaria.
	\item Carattere, come $["a", "Pallw", "30", "TRUE"]$. Notare che qualunque cosa all'interno di apici verrà visto come stringa.
	\item Booleano, come $[TRUE, FALSE]$. Autoesplicativo, dai.
\end{itemize}
\noindent L'allocazione della memoria è gestita dal linguaggio stesso e la variabile viene salvata nell'\textbf{ambiente} di lavoro. Questa rimane utilizzabile fin quando non la si rimuove.\par 
È possibile controllare il tipo di una variabile con la funzione "class(nomeVariabile)". Vediamo ora un esempio di stampa di stringhe insieme a variabili utilizzeremo la funzione di concatenazione:
\begin{verbatim}
	> c1 <- c2 <- c3 <- "A" # Associa il carattere "A" a multiple variabili.
	> class(c1)
	> cat("Questo gioco è un:", c1, c2, c3)
\end{verbatim}
\noindent Passiamo alla matematica del linguaggio. Come già menzionato è possibile effettuare le quattro operazioni elementari, esponente, modulo e divisione intera con rispettivamente $[+, -, *, /, ^, \%\%, \%/\%]$, ma esistono anche funzioni diverse per facilitarci la vita:
\begin{verbatim}
	...
	abs(-4.2)			# Torna il valore assoluta del dato inserito
	sqrt(9)				# Torna la radice quadrata del dato inserito
	min(10, 5, 15)		# Torna il valore minimo dei dati inseriti
	max(10, 5, 15)		# Torna il massimo dei dati inseriti
	ceiling(1.4)		# Torna il numero approssimato per eccesso (2)
	floor(1.4)			# Torna il numero approssimato per difetto (1)
	...
\end{verbatim}
\noindent Abbiamo poi i comparatori la cui sintassi è uguale spiccicata a C:
\begin{verbatim}
	x == y 	# x uguale a y
	x != y	# x diverso da y
	x < y	# x minore di y
	x <= y	# x minore o uguale a y
	x > y	# x maggiore di y
	x >= y	# x maggiore o uguale a y
\end{verbatim}
\noindent Come anche gli operatori logici:
\begin{verbatim}
	&&	# AND logico, torna vero se lo sono ambo gli elementi
	||	# OR logico, torna vero se lo è almeno un elemento
	!	# NOT logico, inverte il valore dell'elemento
\end{verbatim}
\noindent Passiamo a qualcosa di più serio, ma ugualmente semplice; R mantiene i costrutti condizionali e i cicli, quindi abbiamo le costruzioni "if else", "while" e "for".
\begin{verbatim}
	a <- 200
	b <- 33
	
	# Funzionamento del costrutto if else
	if (b > a) {
		print("b is greater than a")
	} else if (a == b) {
		print("a and b are equal")
	} else {
		print("a is greater than b")
	}
	
	c <- 40
	
	# Funzionamento del costrutto while
	while(b < c) {
		# Esegui il codice
		b <- b+1
	}
	
	dice <- c(1, 2, 3, 4, 5, 6)
	
	# Funzionamento del costrutto for
	for (x in dice) {
		print(x)
	} 
\end{verbatim}
\noindent Per la strutturazione corretta di uno script più complesso sarà necessario dividere il tutto in funzioni:
\begin{verbatim}
	my_function <- function(x) {
		return (5 * x)
	}
	
	print(my_function(3))
	print(my_function(5))
	print(my_function(9))
\end{verbatim}

%

\section{Strutture dati di R}
R consente la scrittura di semplici programmi con i costrutti appena visti, ma detiene anche sei strutture dati di tipo più astratto:
\begin{itemize}
	\item Vettori; Una lista di oggetti dello stesso tipo.
	\item Liste; Collezioni di dati ordinate e modificabili.
	\item Matrici; Dataset a due dimensioni composto da righe e colonne.
	\item Array; Collezione di elementi dello stesso tipo che può avere più di due dimensioni.
	\item Dataframes; Collezione di dati di vario tipo salvata in un format matriciale.
	\item Fattori; Utilizzati per la categorizzazione dei dati.
\end{itemize}
\noindent Andiamo con ordine; i \textbf{vettori} sono tali e quali a quelli visti nel linguaggio C; ciò significa che rispetteranno le stesse dinamiche, ma in R detengono anche modalità di accesso e modifica più ampie. Anzitutto, abbiamo più modi per dichiarare un vettore:
\begin{verbatim}
	# Vettore di elementi 5, 10, 15, 20, 25
	> v1 <- c(5, 10, 15, 20, 25)
	# Vettore di elementi in sequenza da 1 a 5	
	> v2 <- 1:5
	# Vettore di elementi da 5 a 25 a passi di 5
	> v3 <- seq(from = 5, to = 25, by = 5)
	# Vettore degli elementi di v3 ripetuti tre volte
	> v4 <- rep(v3, times = 3)
	# Accesso al valore del vettore v1 in posizione 1
	> v1[1]
\end{verbatim}
\noindent Come puoi vedere, è possibile utilizzare il vettore come una semplice variabile senza che il compilatore si lagni. Ciò significa che è possibile dare in pasto alle funzioni la variabile e se la gestirà da sola. In tal merito, abbiamo alcune funzioni utili per lavorare coi vettori:
\begin{itemize}
	\item length(): Calcola la lunghezza del vettore.
	\item max(), min(): Calcolano valore massimo e minimo del vettore.
	\item sum(): Calcola la somma di tutti gli elementi del vettore.
	\item cumsum(): Calcola la somma cumulativa di ogni elemento.
	\item sort(): Ordina il vettore.
\end{itemize}
\noindent Le \textbf{liste} hanno un comportamento uguale ai vettori ed è possibile aggiungerne elementi come anche concatenare più liste:
\begin{verbatim}
	# Dichiarazione delle liste l1, l2
	l1 <- list("Dio", "Gesù", "Maria")
	l2 <- list("Pietro", "Paolo", "Giovanni")
	
	# Accesso all'elemento in posizione 3 di l1
	l1[3]
	
	# Aggiungo l'elemento "Cane" alla lista l1
	append(l1, "Cane")
	
	# Aggiungo l'elemento "Mascio" in posizione 2 alla lista
	append(l1, "Mascio", after = 2)
	
	# Concatenazione di l1 e l2 in l3
	l3 <- c(l1, l2)
\end{verbatim}
\noindent Passiamo ora alle \textbf{matrici}, le quali, come i vettori, detengono le funzioni e accessi presenti in C e molto altro. Abbiamo anche qui vari modi per dichiarare e accedere:
\begin{verbatim}
	# Dichiarazione di una matrice, lega i due vettori come colonne.
	mat1 <- cbind(c(1, 2, 3), c(1, 2, 3))
	
	# Dichiarazione di una matrice, lega i due vettori come righe.
	mat2 <- rbind(c(1, 2, 3), c(1, 2, 3))
	
	# Accesso a elementi in colonne da 1 a 2 e righe da 2 a 3.
	mat1[2:3,1:2]
	
	# Rimuove la prima riga, nessun comando per le colonne.
	mat1[-1,]
	
	# Riempie una matrice di i righe e j colonne del valore n
	mat3 <- matrix(n, i, j)
	
	# Crea una matrice identità di dimensione k
	matIdt <- diag(k)
\end{verbatim}
\noindent Le operazioni utilizzabili dalle matrici seguono quelle viste in algebra lineare, vale a dire somma, sottrazione fra vettori o matrici e divisione, moltiplicazione per scalari, vettori o matrici. Il risultato deve essere salvato in una variabile diversa e l'operazione si scrive semplicemente come fossero due numeri. Seguono altre funzioni utili:
\begin{itemize}
	\item det(): calcola il determinante di una matrice.
	\item qr(): Calcola la decomposizione QR.
	\item solve(): Fa l'inversa di una matrice.
	\item nrow(), ncol(): Ritornano il numero di righe o colonne di una matrice.
	\item rowSums(), colSums(): Fanno la somma dei valori di ogni riga o colonna. 
	\item rowMeans(), colMeans(): Calcola la media dei valori di ogni riga o colonna. 
	\item dim(): Calcola la dimensione di una matrice.
\end{itemize}
\noindent Gli \textbf{array} hanno la possibilità di andare da una a più dimensioni, senza un vero limite. Capirai ovviamente che per una e due dimensioni è preferibile usare le strutture apposite viste prima, quindi mostrerò solo come lavorare in dimensioni superiori.
\begin{verbatim}
	# Dichiarazione di un array a più dimensioni
	a2 <- array(c(1:12), dim = c(2, 3, 2))
	
	# Stampo l'array in toto
	a2
	
	# Accedo alle posizioni i-1st dim, j-2nd dim, k-3rd dim.
	a2[2, 3, 2]
\end{verbatim}
\noindent I \textbf{dataframes} sono strutture bidimensionali che possono salvare dati in un formato matriciale. Si compongono quindi di righe e colonne, le quali possono essere viste come singoli vettori che contengono un tipo di dato; ciò comporta che la struttura può contenere diversi tipi allo stesso tempo:
\begin{verbatim}
	# Dichiaro un dataframe
	df1 <- data.frame(
		mount = c("Everest", "K2", "Fuji"),
		height = c(8848, 8611, 3776),
		todo = c(TRUE, TRUE, FALSE)
	)
	
	# Stampo il dataframe
	df1
	
	# Accedo alla singola colonna mount
	df1$mount
\end{verbatim}
\noindent Essendo inoltre strutturata come una matrice, sarà possibile utilizzare le sue stesse funzioni. Basta immaginarla come una matrice multitipo.\par
Utilizziamo poi i \textbf{fattori} per lavorare con dati categorizzati. Nel creare una struttura dati tale, potrà contenere solamente un insieme di valori fissati detti \textit{livelli}, dati nella dichiarazione.
\begin{verbatim}
	# Dichiaro il fattore f1 col set marital_status di relativi elementi
	f1 <- marital_status <- factor(c("married", "single", "single",
	"divorced", "married"))
	
	# Stampo il fattore
	f1
	
	# Stampo i singoli livelli (ignora ripetizioni)
	levels(f1)
	
	# Provo ad inserire "hey" come livello, fallendo.
	f1[1] <- "Hey"	# In questo caso genererà NA
\end{verbatim}

%

\section{Funzioni di R per i grafici}
R detiene varie funzioni per la rappresentazione dei dati su grafici; oltre a quelle built-in del linguaggio, ne abbiamo aggiunte altre col pacchetto ggplot che ti ho fatto installare ad inizio lettura. Possiamo creare grafici dei seguenti tipi:
\begin{itemize}
	\item \textbf{Barplots}; barplot()
	\item \textbf{Lineplots}; plot(..., type = l)
	\item \textbf{Istogrammi}; hist()
	\item \textbf{Boxplots}; boxplot()
	\item \textbf{Scatterplots}; plot()
	\item \textbf{Heatmaps}; heatmap()
	\item \textbf{Density plots}; plot(density(...))
\end{itemize}
\noindent Tutte queste funzioni condividono le stesse particolarità, ovvero prendono tutte gli stessi valori e li elaborano allo stesso modo. L'unica differenza reale sta nella rappresentazione dei dati. Quindi una scrittura usata per plot() varrà anche per hist(), per esempio.
\begin{verbatim}
	# Dichiaro i dati
	x <- c(1, 2, 3, 4, 5)
	y <- c(6, 7, 8, 9, 10)
	
	# Creo il grafico, in questo caso uno scatterplot
	plot(x,y)
\end{verbatim}
\noindent Le caratteristiche del grafico sono modificabili a proprio piacimento; in particolare puoi modificare nomi degli assi, del grafico intero e i punti che rappresentano i singoli dati.
\begin{verbatim}
	...
	# Creo un grafico customizzato
\end{verbatim}

% TODO ----- RICOMINCIA DA QUA

%

\section{Funzioni di R per la statistica}

% TODO ----- CORREGGERE

Ovviamente, se le variabili contengono valori è possibile effettuare operazioni aritmetiche. Inoltre, esistono due semplici funzioni per familiarizzare con la loro logica:
\begin{itemize}
	\item Per il calcolo della media: mean(x, ...)
	\item Per il calcolo della mediana: median(x, na.rm = FALSE, ...)
\end{itemize}
Nella funzione della mediana notiamo la parola "na.rm"; si tratta di un valore logico con il quale decidere se contare o meno i valori "NA", ovvero \textbf{Not Available}. 

Segue ora esempio di codice con quanto esposto finora:
\begin{verbatim}
	# Assegno i valori 24, 25, 28 alle rispettive variabili A, B, C
	> A <- 24
	> B <- 25
	> C <- 28
	
	# Calcolo la media e la mediana e le salvo in due variabili
	> mn <- mean(A, B, C)
	> md <- median(c(24, 25, 28))
	
	# Stampo a video i risultati
	> cat("Media:", mn, "Mediana:", md)
\end{verbatim}
La riga della mediana fa da apripista per il prossimo argomento.

% TODO RIPRENDI DA LEZIONE 2 - GUARDA I PDF E NON LE LEZIONI