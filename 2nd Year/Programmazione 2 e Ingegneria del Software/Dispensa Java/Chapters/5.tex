\section{Libreria digitale}
Le librerie digitali di Java sono un insieme di funzioni contenute in \textbf{pacchetti} appositi e fornite da terze parti. Come altri utenti ne hanno scritte, così potremmo fare anche noi. In ogni caso, tutti i file da eseguire sono visti come classi, ed infatti dovranno essere compresi nel classpath, se non sono standard.\par
Per utilizzare una libreria è necessario importarla nel file desiderato con la keyword \textbf{import}. Per esempio, nella libreria java.util è presente la classe Scanner, che viene usata per ricevere input da tastiera.
\begin{lstlisting}[language=Java]
	// Aggiunge il pacchetto Scanner dal path java/util/Scanner
	import java.util.Scanner;
	
	public class Mult {
		public static void main(String args[]) {
			
			// Dichiarazione dell'oggetto keyScan di classe Scanner
			Scanner keyScan = new Scanner(System.in);
			int n1, n2;
			
			System.out.print("Inserisci il primo fattore: ");
			// Assegna a n1 l'intero letto da tastiera, idem n2.
			n1 = keyScan.nextInt();
			System.out.print("Inserisci il secondo fattore: ");
			n2 = keyScan.nextInt();
			
			// Chiudi lo scanner con il metodo close().
			keyScan.close();
			System.out.println("Risultato: " + n1*n2);
		}
	}
\end{lstlisting}
\noindent Quindi abbiamo capito che un pacchetto è un insieme di classi le quali sono logicamente correlate. Lo scopo principale è strutturare il codice in modo più chiaro grazie alla modularità che ne consegue. In termini più semplici, è considerabile come una libreria le cui interfacce sono date dalle classi.\par
I pacchetti possono essere innestati ed il path è dato dalla segnatura come visto nello snippet; i punti sostituiscono lo slash. In assenza di una dichiarazione del pacchetto, al file verrà associato quello di default, \textbf{package private}, il quale lo renderà inaccessibile da altri file. L'uso di quest'ultimo è sconsigliato e considerato cattiva pratica.\newline

\noindent La struttura dei pacchetti influenza anche la visibilità delle classi. Per esempio, supponiamo di avere un classpath di pacchetti "it.univr.bugs". Se inseriamo il main all'interno della directory univr e le classi funzionali all'interno di bugs, queste ultime non saranno visibili dalla prima; quindi è necessario importare il pacchetto con le modalità già viste.
\begin{lstlisting}[language=Java]
	package it.univr;	// Specifica del path corrente
	import it.univr.bugs.*;		// Per includere ogni classe
	import it.univr.bugs.Hornet;	// Per includere una classe specifica
\end{lstlisting}

%

\section{java.lang.*}
Il pacchetto java.lang.* comprende la libreria nativa del linguaggio, contenente tutte le funzioni di base come costrutti, oggetti e altri strumenti.

\subsection{Classi wrapper}
Le classi wrapper rappresentano sotto forma di classe i tipi primitivi. Sono compresi di campi e metodi per lavorare in un ambiente completamente orientato agli oggetti. Sono immutabili e si definiscono con lo stesso nome dei tipi primitivi, ma con la prima lettera maiuscola; abbiamo quindi: \textbf{Byte}, \textbf{Short}, \textbf{Integer}, \textbf{Long}, \textbf{Float}, \textbf{Double}, \textbf{Char} e \textbf{Boolean}.\par
Originalmente, per ottenere i valori da queste classi, era necessario fare wrapping e unwrapping coi relativi metodi, tuttavia, da Java 5, è stato implementato nel compilatore il concetto di \textbf{autoboxing} e \textbf{autounboxing}, consentendo di gestire le classi wrapper come si farebbe coi tipi primitivi.
\begin{lstlisting}[language=Java]
	Integer wi = 2;
	int j = 0;
	
	j = wi + 5;	// Sostituisce j = wi.intValue()+5;
	wi = 3;		// Sostituisce wi = new Integer(3);
	wi = j;		// Sostituisce wi = new Integer(j);
\end{lstlisting}
\noindent In particolare, la classe Character ha alcuni metodi statici di utility dal nome particolarmente esaustivo, come per esempio isLetter(), isDigit(), isSpaceChar(), toUpperCase(), toLowerCase() e altri.

\subsection{.System}
La classe System non può essere istanziata e comprende campi e metodi utili per la gestione di input/output standard e flusso. Dà inoltre accesso a proprietà esternamente definite e variabili di ambiente, permette di caricare file e librerie, ed infine un metodo di utility per copiare velocemente una porzione di array.
\begin{lstlisting}[language=Java]
	// Campi visti
	static PrintStream err		// stderr stream
	static InputStream in		// stdin stream
	static PrintStream out		// stdout stream
	
	// Metodi visti
	static long currentTimeMillis() // Ritorna l'ora attuale
\end{lstlisting}

\subsection{.String, StringBuilder}
.String:
Le stringhe son costanti e senza terminatore, str.length(), str.charAt(i), s.equals(t), str.indexOf(c), str.substring(start, end), str.replace(target, replacement), format()

.StringBuilder
StringBuilder delete(int start, int end), StringBuilder insert(int index, String str), StringBuilder reverse()

\subsection{.Math}
La classe Math non è istanziabile e contiene metodi per effettuare operazioni numeriche di base come esponenziali, logaritmi, radici e funzioni trigonometriche.
\begin{lstlisting}[language=Java]
	// Campi visti
	static double E		// 2.71
	static double PI	// 3.14
	
	// Metodi visti
	static int abs (int n)	// Valore assoluto di n
	static double log (double n)	// logaritmo in base e di n
	static double log10 (double n)	// logaritmo in base 10 di n
	static int max (int a, int b)	// Massimo fra a,b
	static int min (int a, int b) 	// Minimo fra a,b
	static long round (double d) 	// Approssimazione per ecc/dif
	static double sin (double r) 	// Seno di angolo r in radianti
	static double cos (double r) 	// Coseno di angolo r in radianti
	static double tan (double r) 	// Tangente di angolo r in radianti
	static double sqrt (double n) 	// Radice quadrata positiva di n
	static double toDegrees (double r) 	// Passa da rad a deg
	static double toRadians (double d) 	// Passa da deg a rad
\end{lstlisting}

\subsection{.Comparable}
L'interfaccia Comparable porta un metodo utile generalizzato per paragonare due oggetti.
\begin{lstlisting}[language=Java]
	// Negativo se this<obj, zero se this=obj e positivo se this>obj
	public int compareTo (T obj)
\end{lstlisting}
\noindent Esempio di utilizzo interfaccia Comparable mantenendo la sua logica facendo override del metoto compareTo:
\begin{lstlisting}[language=Java]
	public class Student extends Person implements Comparable {
		// ...
		@Override
		public int compareTo(Object obj) {
			Student other = (Student) obj;	// cast al tipo specifico
			return this.matricola - other.matricola;
		}
	}
\end{lstlisting}

\begin{comment}
	// Interfaccia comparabile con generics
	java.lang.Comparable<T>	è un interfaccia contenente int compareTo(T obj); Fondamentalmente parliamo di una classe apposita per le comparazioni, alla quale viene dato un generic.
	I metodi potranno poi essere overridati per essere adattati al caso in esame.
	Ritorna 0 se gli oggetti sono uguali, un intero > 0 se il primo oggetto è maggiore dell'altro, mentre un numero < 0 se è minore.
	
	```
	public class Student extends Person implements Comparable <Student> {
		...
		@Override	// Per adattare il metodo alla classe specifica.
		public int compareTo (Student other) {
			return this.matricola − other.matricola;
		}
	}
	```
	
	java.lang.Iterable<E> è un'utile interfaccia contenente il metodo Iterator<E>, Iterator(), che a sua volta contiene metodi boolean HasNext(), E next().
	Queste due interfacce sono inutilizzabili da sole; per usare iterable è necessario implementare iterator, altrimenti sarà impossibile scorrere gli oggetti dati.
	1. Dichiara l'iterable implementato dall'interfaccia, l'oggetto sta dentro le <>, detto operatore diamond.
	2. Definisci costruttore e overrida la funzione Iterator() per adattarne il comportamento.
	3. Dichiara l'iteratore per scorrere l'oggetto in esame, poi overrida le funzioni hasNext e next per adattarne il comportamento.
\end{comment}

\subsection{.Iterable, .Iterator}
Se una classe implementa l'interfaccia Iterable, i suoi oggetti potranno essere iterati con un ciclo for-each grazie al suo uso dell'interfaccia Iterator, parte del JCF, il quale sarà approfondito più avanti.
\begin{lstlisting}[language=Java]
	// Metodi visti
	boolean hasNext ()	// Vero se l'iterazione ha piu' elementi
	E next ()	// Torna il prossimo elemento
\end{lstlisting}
Esempio di utilizzo:\newline
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		import java.lang.Iterable;
		
		class ClassRoom implements Iterable {
			private Student[] students;
			
			ClassRoom(Student[] students) {
				this.students = students;
			}
			
			@Override
			public Iterator iterator () {
				return new CRIterator(students);
			}
		}
	\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		
		class CRIterator implements Iterator {
			private Student[] arr;
			private int next = 0;
		}
		
		CRIterator (Student[] arr) { this.arr = arr; }
		
		@Override
		public boolean hasNext () {
			return next < arr.length;
		}
		
		@Override
		public Object next () {
			return new Student(arr[next++]);
		}
	\end{lstlisting}
\end{minipage}
\begin{lstlisting}[language=Java]
	Student[] arrS = {new Student("Sam", 456), new Student("Paul", 123)};
	ClassRoom classRoom = new ClassRoom(arrS);
	
	for (Object obj:classRoom) {
		System.out.println(((Student)obj).toString)
	}
\end{lstlisting}



\begin{comment}
	\subsection{.AutoCloseable}
	\subsection{.Thread}
\end{comment}

\section{java.util.*}
Il pacchetto java.util.* contiene varie funzioni di utility per rendere il codice più leggibile, astratto, modulare e sicuro.
\subsection{.Scanner}
netxLine, nextInt, nextFloat

\subsection{.Random}
La classe Random è istanziabile, ed è usata per la generazione di variabili pseudocasuali.
\begin{lstlisting}[language=Java]
	// Costruttori
	Random()
	Random(long seed)
	
	// Metodi
	boolean nextBoolean()	// Casuale true/false
	double nextDouble()		// Decimale fra [0.0, 1.0)
	float nextFloat()		// Decimale fra [0.0, 1.0)
	int nextInt()			// Casuale intero [-2^31, 2^31)
	int nextInt(int max)	// Casuale intero [0, max)
	long nextLong()			// Casuale intero [-2^63, 2^63)
\end{lstlisting}

\subsection{.Arrays}

\subsection{Java Collection Framework}

\begin{comment}
	\subsection{Strutture dati}
	java.util.Collection<E>, java.util.List<E>, java.util.Queue<E>, java.util.Set<E>, java.util.LinkedList<E>, java.util.ArrayList<E>, java.util.PriorityQueue<E>
	java.util.HashSet<E>, java.util.SortedSet<E>, java.util.TreeSet<E>, java.util.Map<K,V>, java.util.HashMap<K,V>, java.util.SortedMap<K,V>, java.util.TreeMap<K,V>
\end{comment}

\section{java.io.*}
Il pacchetto java.io.* fornisce funzioni relative alla gestione di un flusso di dati, sia in input, che in output.

\begin{comment}
	\subsection{.Closeable}
	\subsection{.Reader, .FileReader, .BufferedReader}
	\subsection{.Writer, .FileWriter, .BufferedWriter, .PrintWriter}
\end{comment}






\begin{comment}
	\noindent Continuiamo ragionando sull'ultima istruzione dello snippet appena visto. Le stringhe, come già detto, sono viste come oggetti, e per usarle bisogna istanziare un oggetto. Dopodiché, non saranno più mutabili in quanto non sono viste come sequenze di caratteri. Tuttavia, abbiamo a disposizione alcuni metodi con cui lavorarci:
	\begin{lstlisting}[language=Java]
		String str = new String("SHAW!");
		String same = new String("SHAW!");
		
		System.out.println(str.length());		// Stampa la lunghezza di una stringa.
		System.out.println(str.charAt(4));		// Stampa il singolo carattere alla posizione 4.
		System.out.println(str.equals(same));	// Confronta str e same, torna vero se sono uguali.
		str.indexOf(a) 							// Ricerca del carattere 'a' all'interno della stringa. Se assente torna -1, altrimenti torna l'indice.
		str.substring(start, end)				// Ottiene una sottostringa con gli indici dati in input. Crea una nuova stringa.
		str.replace(target, replacement)		// Rimpiazza i caratteri di target con quelli di replacement.
	\end{lstlisting}
	\noindent La classe String possiede anche il metodo \textbf{format}. Permette di formattare la stringa con una sintassi simil-C, ed è utile per mantenere un template.
	\begin{lstlisting}[language=Java]
		String str = new String("Egale");
		int num = 2;
		
		// Dona un formato alla stringa
		String formatStr = String.format("%s = %d", str, num);
		System.out.println(formatStr);
	\end{lstlisting}
	\noindent Sebbene gli oggetti da String diventino costanti post-inizializzazione, java.lang fornisce la classe \textbf{StringBuilder}, che consente di gestire dinamicamente una stringa.
	\begin{lstlisting}[language=Java]
		StringBuilder sb = new StringBuilder("Droxie");				// Crea una stringa mutevole
		sb.append("kaliemu");										// Concatena in coda i caratteri fra le virgolette.
	\end{lstlisting}
	\noindent È possibile anche cancellare ed inserire sottostringhe con i metodi \textbf{delete} ed \textbf{insert}. Insomma, le stringhe base sono costanti, mentre le stringhe mutevoli di StringBuilder sono sicuramente più flessibili.
\end{comment}