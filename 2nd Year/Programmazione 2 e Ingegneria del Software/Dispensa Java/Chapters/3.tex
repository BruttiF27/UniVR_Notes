\section{Incapsulamento}
L'incapsulamento è un concetto che ha origine nelle modalità di interazione nel mondo reale. Così come per interagire con una persona si usa la voce per ottenere informazioni specifiche, allo stesso modo gli oggetti comunicano con interfacce apposite al fine di ritornare dati. Questa filosofia si ottiene controllando l'accesso ai dati tramite le keyword dei modificatori di accesso. Più precisamente, bisogna:
\begin{enumerate}
	\item Dichiarare gli attributi di una classe come \textbf{privati}, per renderli inaccessibili ad altre classi al di fuori di questa.
	\item Creare dei metodi \textbf{pubblici} per accedere, modificare e riportare gli attributi privati in maniera controllata, talvolta con dei controlli per assicurarsi che i dati siano presentati con certe caratteristiche. Questi metodi si chiamano \textbf{setter}, per assegnare il dato all'oggetto, e \textbf{getter}, per accedere al dato dell'oggetto.
\end{enumerate}
\begin{lstlisting}[language=Java]
	public class Date {
		private int day, month, year;
		
		// Metodo setter per garantire che giorno sia un valore corretto
		public void setDay (int g) {
			if (j >= 1 && j<= 31) giorno = g;
			else System.out.println("Invalid day");
		}
		
		// Metodo getter per ritornare il valore in sicurezza
		public int getDay () { return day; }
		
		public void setMonth (int m) {
			if (m <= 1 && m <= 12) month = m;
			else System.out.println("Invalid month");
		}
		
		public int getMonth () { return month; }
	
		public void setYear (int y) {
			if (y <= 0) year = y;
			else System.out.println("Invalid year");
		}
		
		public int getYear () { return year; }
	}
\end{lstlisting}

%

\section{Ereditarietà}
Quello di \textbf{ereditarietà} è un concetto strettamente legato all'insiemistica. Partiamo dal presupposto che esiste un insieme universo, il quale comprende ogni singola altra cosa nel mondo; in Java, le classi funzionano con la medesima dinamica. Tutte le classi sono un sottoinsieme improprio di \textbf{Object}, la quale presenta i seguenti metodi per noi importanti:
\begin{itemize}
	\item \textbf{protected Object clone()}: Istanzia e ritorna una copia dell'oggetto richiesto.
	\item \textbf{boolean equals(Object obj)}: Controlla se un oggetto è uguale a quello chiamante.
	\item \textbf{int hashCode()}: Ritorna il valore dell'hashcode dell'oggetto chiamante, ovvero la parte sinistra alla chiocciola della reference.
	\item \textbf{String toString()}: Ritorna una rappresentazione dell'oggetto sotto forma di stringa.
\end{itemize}
\noindent Tutte le classi, e quindi anche i tipi, sono \textbf{estensioni} della classe Object, e di conseguenza potranno chiamare ed eseguire i metodi in essa contenuti. Questo concetto è naturalmente replicabile con ulteriori sottoclassi, quindi ci è concesso creare nuovi metodi e campi riutilizzabili in più file senza che vengano ridefiniti. La potenzialità di questo paradigma sta nella riduzione all'estremo di codice ripetuto; le sottoclassi sono quindi capaci di attingere da ciò che è definito nella superclasse, e, nel caso dei metodi, fare ciò che è chiamato \textbf{overriding}\par
Supponiamo ora di avere una classe "Vehicle". Il concetto di veicolo è specificabile in sottoinsiemi come automobili, biciclette e simili. In Java ciò si traduce come:
\begin{lstlisting}[language=Java]
	public class Vehicle {
		protected int num;
		protected int getNum() { /* Blocco di codice */}
		public Vehicle { /* Blocco del costruttore */ }
	}
	
	// Estensione di Vehicle, chiama il metodo per ottenere il numero.
	public class Car extends Vehicle {
		public Car { 
			this.num = super.getNum();
		}
	}
	
	// Ridefinizione di getNum per mantenere lo stesso nome e semplificare il codice
	public class Bicycle extends Vehicle {
		@Override
		public int getNum() { /* Ridefinizione del codice */ }
	}
\end{lstlisting}
\noindent L'accesso a campi e metodi della superclasse avviene tramite la keyword \textbf{super}, se questi sono stati dichiarati come pubblici o protetti. Questa parola è anche strettamente legata al metodo costruttore; questo non è ereditato dalle sottoclassi, tuttavia è necessario che queste abbiano anche le caratteristiche della superclasse e siano costruite in tali termini. In soldoni, i costruttori non sono ereditati ed ogni sottoclasse ha bisogno del prorpio, ma quest'ultimo chiamerà necessariamente il costruttore della sovracclasse con super().\par
La ridefinizione è invece per prima cosa segnalata da \textbf{@Override}, per poi riscrivere il blocco di codice. Quest'ultima feature è particolarmente utile per mantenere il numero di nomi basso e rendere il codice più chiaro a livello di struttura.\par
Un'ultima caratteristica del linguaggio utile è la possibilità di controllare se una classe è superclasse di un'altra, con la keyword \textbf{instanceof}. Per esempio, in un codice che rappresenta Person, Student, Lecturer e Sam avremo:
\begin{lstlisting}[language=Java]
	Student sam = new Student();
	
	(sam instanceof Student)	// True, Identita'.
	(sam instanceof Person)		// True, Person sovracclasse di Student.
	(sam instanceof Lecturer)	// False, Student non legato a Lecturer.
	(sam instanceof Object)		// Tautologia.
\end{lstlisting}
\noindent Un compito comune da eseguire in campo di ereditarietà ed istanziazione di oggetti è controllare se questi siano uguali o meno; come già specificato, la classe Object ha con sé il metodo equals(), che consente di fare proprio questo. Tuttavia, Java salva gli oggetti con riferimenti diversi per differenziarli, indipendentemente dal loro contenuto. Supponiamo per esempio di istanziare due stringhe sintatticamente uguali; se non ridefinito correttamente, come da suo funzionamento, ritornerà false.\par
Dunque qui abbiamo due strade per correggere questo comportamento. Possiamo fare overriding del metodo equals() e specificare che cosa deve essere uguale per far sì che ritorni true, oppure più semplicemente ridefinire questo metodo insieme ad hashCode(). Per quest'ultima soluzione è necessario far sì che la stessa reference sia assegnata ad ogni oggetto i cui campi sono uguali ad un altro.\par
Un'altra dinamica a cui prestare attenzione è legata all'incapsulamento; generalmente, i campi dichiarati nelle superclassi, a meno che non si voglia siano condivisi a tutti i figli, sono dichiarati come privati; sarà quindi necessario utilizzare metodi getter per potervi accedere, in quanto sono gestiti come pubblici.

%

\section{Polimorfismo}
Per \textbf{polimorfismo} intendiamo un'entità che può assumere più forme; nella programmazione a oggetti si può implementare in diverse modalità. Per esempio, restando sempre nel campo dei riferimenti, diciamo che una reference di tipo $T$ può puntare ad un oggetto di tipo $S$ se e solo se $S$ è $T$ oppure una sua sottoclasse. In quest'ultimo caso, gli oggetti di tipo $T$ possono essere rimpiazzati da oggetti di tipo $S$, usando il \textbf{principio di sostituzione di Liskov}; quindi:
\begin{lstlisting}[language=Java]
	Person p;
	p = new Person();		// Corretto, T=S.
	p = new Student();		// Corretto, T sottoinsieme di S
	
	Person person = new Person("Paul");
	Student student = new Student ("Sam", 123);
	person = student;		// Sostituzione corretta, assegnato un sottotipo
	student = person;		// Errore di compilazione.
\end{lstlisting}
\noindent Nell'ultimo caso, l'errore avviene perché il compilatore effettua una ricerca ricorsiva dei metodi, partendo dalla sottoclasse fino ad arrivare a Object. Se ritorna un problema, è perché non trova il metodo chiamato in nessuna delle classi, quindi bisogna fare attenzione a rispettare i parametri da dare alle funzioni.\par
Abbiamo già menzionato il concetto di type casting; la stessa dinamica è applicabile agli oggetti, in due direzinoni:
\begin{itemize}
	\item \textbf{Upcast}: Garantito dal principio di sostituzione, type safe. Visto nello snippet di prima, dove ad un oggetto person è assegnato uno student. Si può scrivere implicitamente poiché è eseguito dal compiler in runtime.
	\item \textbf{Downcast}: Necessario esplicitarlo, non ha garanzia di essere type safe. Nel caso di prima, riguarda il caso di errore di compilazione; per far sì che sia corretto bisogna castare il tipo Student prima di person. Per evitare eventuali problemi è consigliato l'utilizzo di instanceof per controllare le superclassi.
\end{itemize}

%

\section{Astrazione}
Per \textbf{astrazione} intendiamo la possibilità di descrivere la forma del programma senza implementarne le funzionalità. Risulta utile sia per avere una chiara definizione della struttura delle classi, sia per, come vedremo più avanti, utilizzarle come esempio e ridurre drasticamente la dimensione del codice.\par
Introduciamo quindi il nuovo modificatore \textbf{abstract}, il quale è utilizzabile su metodi e classi; nel primo caso consente di descrivere una funzionalità della classe senza definire il suo funzionamento, ragion per cui il metodo non sarà invocabile e definibile esclusivamente in \textbf{classi astratte}. Queste ultime hanno la particolarità di avere almeno un metodo astratto, il quale rende impossibile una loro istanziazione.\par
Qui entra in gioco l'ereditarietà; per poter utilizzare classi astratte sarà necessario estenderle in sottoclassi normali con tutti i metodi definiti. L'utilità è lampante: descrivere un comportamento generale che avrà caratteristiche specifiche per ogni sottoclasse, ridefinito grazie all'override dei metodi. Questo è un paradigma di programmazione, infatti, e si chiama \textbf{Template}.
\begin{lstlisting}[language=Java]
	// Definizione della classe astratta
	public abstract class Strumento {
		public String nome;
		public String prezzo;
		// Metodo che rende la classe effettivamente astratta
		public abstract void SuonaFaDiesis();
	}
	
	// Estensione concreta di Strumento per renderla istanziabile
	public class Chitarra extends Strumento {
		@Override
		public void SuonaFaDiesis () { /* Ridefinizione */ }
	}
	
	// Estensione astratta di strumento
	public abstract class StrumentoAFiato extends Strumento { }
	
	public class Flauto extends StrumentoAFiato {
		@Override
		public void SuonaFaDiesis () { /* Ridefinizione */ }
	}
\end{lstlisting}
\noindent Se portiamo il concetto di classe astratta all'estremo, quindi ogni metodo della classe sarà definito come astratto, arriveremo a quella che è considerata un'\textbf{interfaccia} pubblica. Rappresentano la parte dell'oggetto visibile ed interagibile dall'esterno, nascondendo i procedimenti interni; sono tutte intrinsecamente definite come pubbliche e astratte.\par
Naturalmente, non essendo concrete, non possono essere definite e sono viste come tipo esclusivamente per il riferimento. Inoltre, ogni metodo ivi presente è pubblico, mentre i campi sono statici e finali. Le interfacce non si estendono, ma vengono \textbf{implementate} con l'apposita keyword \textbf{implements}, la quale svolge un lavoro analogo ad extends, permettendo di ereditare la forma dei metodi e dei campi alla sottoclasse implementativa.
\begin{lstlisting}[language=Java]
	// Dichiarazione di interfaccia
	public interface Pesabile {
		String UDM = "Kg";		// Implicitamente anche static final
		double getPeso();
	}
	
	// Implementazione di interfaccia
	public class Articolo implements Pesabile {
		private double peso;
		private String descrizione;
		
		public Articolo (String descrizione, double peso) {
			setDescrizione(descrizione);
			setPeso(peso);
		}
		
		@Override
		public double getPeso () {
			return peso;
		}
	}
\end{lstlisting}
\noindent Sebbene non si possano ereditare più classi, per una classe concreta è possibile implementare più interfacce allo stesso tempo, mentre un'interfaccia può estenderne una o multiple senza poterle implementare.

% Interfacce funzionali







- Classi anonime, espressioni lambda, interfacce funzionali
- Parametri varargs, tipi generici, libreria Comparable<T>. Vincoli sulle variabili di tipo


\begin{comment}
	Da decidersi:
	- Javadoc
	
	- Race condition, Deadlock, synchronized
	- Stream lazy
\end{comment}