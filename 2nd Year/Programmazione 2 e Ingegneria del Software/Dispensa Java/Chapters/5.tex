\section{Libreria digitale}
Le librerie digitali di Java sono un insieme di funzioni contenute in \textbf{pacchetti} appositi e fornite da terze parti. Come altri utenti ne hanno scritte, così potremmo fare anche noi. In ogni caso, tutti i file da eseguire sono visti come classi, ed infatti dovranno essere compresi nel classpath, se non sono standard.\par
Per utilizzare una libreria è necessario importarla nel file desiderato con la keyword \textbf{import}. Per esempio, nella libreria java.util è presente la classe Scanner, che viene usata per ricevere input da tastiera.
\begin{lstlisting}[language=Java]
	// Aggiunge il pacchetto Scanner dal path java/util/Scanner
	import java.util.Scanner;
	
	public class Mult {
		public static void main(String args[]) {
			
			// Dichiarazione dell'oggetto keyScan di classe Scanner
			Scanner keyScan = new Scanner(System.in);
			int n1, n2;
			
			System.out.print("Inserisci il primo fattore: ");
			// Assegna a n1 l'intero letto da tastiera, idem n2.
			n1 = keyScan.nextInt();
			System.out.print("Inserisci il secondo fattore: ");
			n2 = keyScan.nextInt();
			
			// Chiudi lo scanner con il metodo close().
			keyScan.close();
			System.out.println("Risultato: " + n1*n2);
		}
	}
\end{lstlisting}
\noindent Quindi abbiamo capito che un pacchetto è un insieme di classi le quali sono logicamente correlate. Lo scopo principale è strutturare il codice in modo più chiaro grazie alla modularità che ne consegue. In termini più semplici, è considerabile come una libreria le cui interfacce sono date dalle classi.\par
I pacchetti possono essere innestati ed il path è dato dalla segnatura come visto nello snippet; i punti sostituiscono lo slash. In assenza di una dichiarazione del pacchetto, al file verrà associato quello di default, \textbf{package private}, il quale lo renderà inaccessibile da altri file. L'uso di quest'ultimo è sconsigliato e considerato cattiva pratica.\newline

\noindent La struttura dei pacchetti influenza anche la visibilità delle classi. Per esempio, supponiamo di avere un classpath di pacchetti "it.univr.bugs". Se inseriamo il main all'interno della directory univr e le classi funzionali all'interno di bugs, queste ultime non saranno visibili dalla prima; quindi è necessario importare il pacchetto con le modalità già viste.
\begin{lstlisting}[language=Java]
	package it.univr;	// Specifica del path corrente
	import it.univr.bugs.*;		// Per includere ogni classe
	import it.univr.bugs.Hornet;	// Per includere una classe specifica
\end{lstlisting}

%

\section{java.lang.*}
Il pacchetto java.lang.* comprende la libreria nativa del linguaggio, contenente tutte le funzioni di base come costrutti, oggetti e altri strumenti.

\subsection{Classi wrapper}
Le classi wrapper rappresentano sotto forma di classe i tipi primitivi. Sono compresi di campi e metodi per lavorare in un ambiente completamente orientato agli oggetti. Sono immutabili e si definiscono con lo stesso nome dei tipi primitivi, ma con la prima lettera maiuscola; abbiamo quindi: \textbf{Byte}, \textbf{Short}, \textbf{Integer}, \textbf{Long}, \textbf{Float}, \textbf{Double}, \textbf{Char} e \textbf{Boolean}.\par
Originalmente, per ottenere i valori da queste classi, era necessario fare wrapping e unwrapping coi relativi metodi, tuttavia, da Java 5, è stato implementato nel compilatore il concetto di \textbf{autoboxing} e \textbf{autounboxing}, consentendo di gestire le classi wrapper come si farebbe coi tipi primitivi.
\begin{lstlisting}[language=Java]
	Integer wi = 2;
	int j = 0;
	
	j = wi + 5;	// Sostituisce j = wi.intValue()+5;
	wi = 3;		// Sostituisce wi = new Integer(3);
	wi = j;		// Sostituisce wi = new Integer(j);
\end{lstlisting}
\noindent In particolare, la classe Character ha alcuni metodi statici di utility dal nome particolarmente esaustivo, come per esempio isLetter(), isDigit(), isSpaceChar(), toUpperCase(), toLowerCase() e altri.

\subsection{.System}
La classe System non può essere istanziata e comprende campi e metodi utili per la gestione di input/output standard e flusso. Dà inoltre accesso a proprietà esternamente definite e variabili di ambiente, permette di caricare file e librerie, ed infine un metodo di utility per copiare velocemente una porzione di array.
\begin{lstlisting}[language=Java]
	// Campi visti
	static PrintStream err		// stderr stream
	static InputStream in		// stdin stream
	static PrintStream out		// stdout stream
	
	// Metodi visti
	static long currentTimeMillis() // Ritorna l'ora attuale
\end{lstlisting}

\subsection{.String, .StringBuilder}
Le classi String, StringBuilder e StringJoiner sono utilizzate per la manipolazione di stringhe. Lavorano su oggetti immutabili. Le ultime due possono anche prendere delle stringhe già esistenti e convertirle in loro oggetti.
\begin{lstlisting}[language=Java]
	// Metodi visti - String
	String("Caratteri")		// Costruttore
	int length()			// Lunghezza della stringa
	char charAt(int index)		// Carattere a indice index
	int indexOf(int ch)		// ch in stringa? Y=indice/n=-1
	String substring(int beginIndex, int endIndex) // Ottiene substring
	String replace(char oldChar, char newChar) // Sostituisce old con new
	
	// Metodi visti - StringBuilder
	StringBuilder("Caratteri")	// Costruttore
	StringBuilder append("caratteri")	// Concatena alla stringa
	StringBuilder insert(int index, String str)	// inserisce str a partire da index
	StringBuilder delete(int beginIndex, int ednIndex) // Cancella caratteri negli indici
\end{lstlisting}

\subsection{.Math}
La classe Math non è istanziabile e contiene metodi per effettuare operazioni numeriche di base come esponenziali, logaritmi, radici e funzioni trigonometriche.
\begin{lstlisting}[language=Java]
	// Campi visti
	static double E		// 2.71
	static double PI	// 3.14
	
	// Metodi visti
	static int abs (int n)	// Valore assoluto di n
	static double log (double n)	// logaritmo in base e di n
	static double log10 (double n)	// logaritmo in base 10 di n
	static int max (int a, int b)	// Massimo fra a,b
	static int min (int a, int b) 	// Minimo fra a,b
	static long round (double d) 	// Approssimazione per ecc/dif
	static double sin (double r) 	// Seno di angolo r in radianti
	static double cos (double r) 	// Coseno di angolo r in radianti
	static double tan (double r) 	// Tangente di angolo r in radianti
	static double sqrt (double n) 	// Radice quadrata positiva di n
	static double toDegrees (double r) 	// Passa da rad a deg
	static double toRadians (double d) 	// Passa da deg a rad
\end{lstlisting}

\subsection{.Comparable, .Comparator}
L'interfaccia Comparable porta un metodo utile generalizzato per paragonare due oggetti.
\begin{lstlisting}[language=Java]
	// Negativo se this<obj, zero se this=obj e positivo se this>obj
	public int compareTo (T obj)
\end{lstlisting}
\noindent Esempio di utilizzo interfaccia Comparable mantenendo la sua logica facendo override del metoto compareTo:
\begin{lstlisting}[language=Java]
	public class Student extends Person implements Comparable {
		// ...
		@Override
		public int compareTo(Object obj) {
			Student other = (Student) obj;	// cast al tipo specifico
			return this.matricola - other.matricola;
		}
	}
\end{lstlisting}

\subsection{.Iterable, .Iterator}
Se una classe implementa l'interfaccia Iterable, i suoi oggetti potranno essere iterati con un ciclo for-each grazie al suo uso dell'interfaccia Iterator, parte del JCF, il quale sarà approfondito più avanti.
\begin{lstlisting}[language=Java]
	// Metodi visti
	boolean hasNext ()	// Vero se l'iterazione ha piu' elementi
	E next ()	// Torna il prossimo elemento
\end{lstlisting}
Esempio di utilizzo:\newline
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		import java.lang.Iterable;
		
		class ClassRoom implements Iterable {
			private Student[] students;
			
			ClassRoom(Student[] students) {
				this.students = students;
			}
			
			@Override
			public Iterator iterator () {
				return new CRIterator(students);
			}
		}
	\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		
		class CRIterator implements Iterator {
			private Student[] arr;
			private int next = 0;
		}
		
		CRIterator (Student[] arr) { this.arr = arr; }
		
		@Override
		public boolean hasNext () {
			return next < arr.length;
		}
		
		@Override
		public Object next () {
			return new Student(arr[next++]);
		}
	\end{lstlisting}
\end{minipage}
\begin{lstlisting}[language=Java]
	Student[] arrS = {new Student("Sam", 456), new Student("Paul", 123)};
	ClassRoom classRoom = new ClassRoom(arrS);
	
	for (Object obj:classRoom) {
		System.out.println(((Student)obj).toString)
	}
\end{lstlisting}

%

\section{java.util.*}
Il pacchetto java.util.* contiene varie funzioni di utility per rendere il codice più leggibile, astratto, modulare e sicuro.

\subsection{.Random}
La classe Random è istanziabile, ed è usata per la generazione di variabili pseudocasuali.
\begin{lstlisting}[language=Java]
	// Costruttori
	Random()
	Random(long seed)
	
	// Metodi
	boolean nextBoolean()	// Casuale true/false
	double nextDouble()		// Decimale fra [0.0, 1.0)
	float nextFloat()		// Decimale fra [0.0, 1.0)
	int nextInt()			// Casuale intero [-2^31, 2^31)
	int nextInt(int max)	// Casuale intero [0, max)
	long nextLong()			// Casuale intero [-2^63, 2^63)
\end{lstlisting}

\subsection{Java Collection Framework}
La Java Collection Framework è un insieme di strutture dati iterabili definite tramite l'uso di parametri generici, rendendole utilizzabili in qualunque contesto. Si tratta di uno dei pacchetti più importanti di tutto il linguaggio.\par
Tutte le strutture dati del framework estendono l'interfaccia padre \textbf{Collection}, la quale porta svariati metodi utili:
\begin{lstlisting}[language=Java]
	public interface Collection<E> extends Iterable<E> {
		int size ();
		int hasCode ();
		boolean equals (Object obj); // Notare equals non generic
		boolean isEmpty ();
		boolean contains (Object obj);
		boolean containsAll (Collection<?> c);
		boolean add (E e);
		boolean addAll (Collection<? extends E>);
		boolean remove (Object obj);
		boolean removeAll (Collection <?> c);
		void clear ();
		Object[] toArray ();
		Iterator<E> iterator (); // from Iterable<E>
	}
\end{lstlisting}
\noindent le strutture dati sottoclassi di Collection si riassumono in tre macrocategorie, date da:
\begin{itemize}
	\item \textbf{List}: Una lista di elementi, la quale può avere duplicati e dove si mantiene l'ordine di inserimento. Sottoclassi sono \textbf{ArrayList} e \textbf{LinkedList}.
	\item \textbf{Queue}: Una lista di elementi legati da una relazione di ordinamento. Sottoclassi sono \textbf{Dequeue} e \textbf{PriorityQueue}.
	\item \textbf{Set}: Insieme di elementi unici. Sottoclasse è \textbf{HashSet}.
\end{itemize}
\noindent Il modo corretto per la dichiarazione di queste strutture è istanziare la sottoclasse a partire dalla sovracclasse, funzionale grazie al principio di sostituzione.
\begin{lstlisting}[language=Java]
	// Esempio di implementazione
	Collection<Person> list = new LinkedList<>();	// Crea lista
	list.add(new Person("Joe"));	// Aggiunge Joe in coda alla lista
	list.add(new Person("Sam"));
\end{lstlisting}
\noindent Naturalmente ogni struttura avrà metodi per facilitarne il workflow. Abbiamo un insieme di metodi condivisi fra List e Queue, mentre per Set sono sufficienti quelli ereditati da Collection.
\begin{lstlisting}[language=Java]
	// Metodi per List e Queue
	E get (int i);	// Ottieni l'elemento a posizione i
	E set(int i, E e);	// Rimpiazza l'elemento e a posizione i
	void set(int i, E e);	// Aggiungi elemento e a posizione i
	E remove(int i);	// Rimuovi elemento a posizione i
	int indexOf(E e);	// Ritorna la posizione dell'elemento e
	List<E> subList(int l, int r);	// Ritorna lista fra gli indici [l,r)
\end{lstlisting}
\noindent Un'utile implementazione di Set si ha con la sua sottoclasse \textbf{HashSet}, la quale consente l'accesso agli elementi della struttura a tempo costante in base a una determinata chiave. Questa struttura dati mantiene ineternalmente una HashMap, la quale garantisce l'unicità degli elementi usando il loro \textbf{hashcode} come chiave.\par
Per una corretta generazione del codice si deve usare il metodo \textbf{hash(obj1, obj2)}, dato dalla classe Object, per poi fare override di equals() con lo scopo di basarlo sulla chiave. Un'altra implementazione utile di Set è \textbf{TreeSet}, basata sulla logica degli RB-Alberi. Aggiunge i metodi first() e last() per prendere il nodo radice e l'ultimo del cammino rispettivamente.\newline

\noindent Un'ultima struttura sempre facente parte del JCF ma non ereditante Collection è la \textbf{Map<K, V>}, dove K sta per key e V per value. Si tratta di un insieme di associazioni che collegano una specifica chiave ad un determinato valore. Capirai che Set e Map sono strettamente legati. Presenta i seguenti metodi:
\begin{lstlisting}[language=Java]
	V put(K key, V values);	// Inserisci associamento
	V get(Object key);	// Torna il valore associato alla chiave
	V remove(Object key);	// Rimuovi l'associamento della chiave
	boolean containsKey(Object key);	// Vedi se la mappa ha una chiave
	boolean containsValue(Object value);	// Torna se valore in mappa
	Set<K> keySet();	// Ritorna le chiavi della mappa
	Collection<V> values();	// Ritorna i valori nella mappa
\end{lstlisting}
\noindent La JCF rende il il codice estremamente standardizzato; tuttavia non basta creare gli oggetti, bisogna anche poterci lavorare.\par
Le mansioni principali sono quelle di scorrere gli elementi e il loro ordinamento; questo lavoro è reso semplice grazie alla sinergia con le interfacce Iterable e Comparable e di conseguenza anche con Iterator e Comparator.

\subsection{Interfacce funzionali primitive}
Le interfacce funzionali sono un argomento già menzionato nei capitoli precedenti, tuttavia è possibile usufruire delle loro versioni base e di uso comune definite in questo pacchetto, date da:\newline

\noindent \textbf{- Predicate}\par
\noindent Prende un parametro di tipo T e ritorna un boolean. Viene spesso usato per filtrare elementi in una collection.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Predicate<T> {
		boolean test(T t);	// Qui T e' generics, ma puo' essere specificato
	}
	
	// Versione semplice
	Predicate<Integer> isEven = new Predicate<>() {
		@Override
		public boolean test(Integer n) { return n%2 == 0; }
	}
	
	// Versione lambda
	Predicate<Integer> isEven = n -> n%2 == 0;
	
	System.out.println(isEven.test(2)); // true
	System.out.println(isEven.test(3)); // false
\end{lstlisting}
\noindent \textbf{- Function}\par
\noindent Prende un parametro di tipo T e ritorna un risultato di tipo R. Spesso usato per mappare un valore ad un altro.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Function<T, R> {
		R apply(T t);
	}
	
	// Function strLen prende String e ritorna Integer
	Function<String, Integer> strLen = str -> str.length();
	
	Systm.out.println(strLen.apply("Hello"));	// Qua stampa 5
\end{lstlisting}
\noindent \textbf{- BiPredicate}\par
\noindent Prende due parametri di tipi T e U per ritornare un boolean
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface BiPredicate<T, U> {
		boolean test(T t, U u);
	}
	
	// La lambda isGreaterThan prende i due parametri e ritorna se la condizione e' vera
	BiPredicate<Integer, Integer> isGreaterThan = (a,b) -> a > b
	
	System.out.println(isGreaterThan.test(2, 5)); // false
	System.out.println(isGreaterThan.test(3, 1)); // true
\end{lstlisting}
\noindent \textbf{- BiFunction}\par
\noindent Prende due parametri di tipi T, U e ritorna un risultato di tipo R, spesso usata per implementare operazioni su due valori.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface BiFunction<T, U, R> {
		R apply(T t, U u);
	}
	
	BiFunction<Integer, Integer, Integer> sumInt = (a,b) -> a+b;
	
	System.out.println(sumInt.apply(3,9));	// Stampa 12
\end{lstlisting}
\noindent \textbf{- Consumer}\par
\noindent Prende un parametro di tipo T e non ritorna niente. Spesso usata per modellare effetti collaterali.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Consumer<T> {
		void accept(T t);
	}
	
	// La lambda ha un effetto sull'argomento, ma non ritorna nulla
	Consumer<String> printUC = str -> System.out.println(str.toUpperCase());
	
	printUC.accept("string");	// Stampa STRING
\end{lstlisting}
\noindent \textbf{- Supplier}\par
\noindent Funzione che non prende parametri ma ritorna un valore di tipo T; spesso usata per la generazione di valori
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Supplier<T> {
		T get();
	}
	
	Supplier<Double> randomNum = () -> Math.random();
	System.out.println(randomNum.get());		// Stampa il numero casuale
\end{lstlisting}
\noindent Ulteriori interfacce funzionali sono date da: \begin{center}
	\textbf{UnaryOperator<T>} extends Function<T, T>, \textbf{BinaryOperator<T>} extends BiFunction<T, T, T>
\end{center}
\noindent Dove la prima prende un parametro T per ritornarne un altro, mentre la seconda ne prende due di tipo T per ritornarne un terzo. Esiste infine una sintassi compatta per fare method reference:
\begin{lstlisting}[language=Java]
	// Sintassi compatta
	System.out::println
	// Equivale a
	str -> System.out.println(str)
\end{lstlisting}
\noindent Generalmente, valgono queste regole:
\begin{itemize}
	\item Per metodi statici: Class::staticMethod
	\item Per metodi d'istanza: object::instanceMethod
	\item Per metodi non statici: Class::nonStaticMethod
	\item Per il costruttore: Class::new
\end{itemize}	

\subsection{.Stream}
Da Java8, il pacchetto java.util.stream contiene classi apposite per processare i flussi di dati. Un flusso è una sequenza di elementi di una fonte e si definisce con la classe \textbf{Stream<T>}. La sequenza supporta operazioni di processione dati, definite tramite interfacce funzionali. I flussi hanno nativamente pipelining, iterazioni interne e parallelizzazioni. Alcuni utilizzi comuni sono:
\begin{lstlisting}[language=Java]
	// Stream.of(T... elems) scorre ogni elemento dato come parametro.
	Stream<String> stream = Stream.of("a", "b", "c");
	
	// Arrays.stream(T[] arr) scorre ogni elemento di un dato array.
	String[] arr = new String[] {"d", "e", "f"};
	Stream<String> stream = Arrays.stream(arr);
	
	// Collection.stream() scorre ogni elemento di una collezione del JCF
	Set<String> set = Set.of("g", "h", "i");
	Stream<String> stream = set.stream();
	
	// Crea una lista a partire dallo stream
	List<Integer> list = Stream.of(1, 2, 2, 3).toList(); 
	
	// Crea un set a partire dallo stream
	Set<Integer> set = Stream.of(1, 2, 2, 3).collect(Collectors.toSet()); 
	
	// Crea un array a partire dallo stream
	Integer[] arr = Stream.of(1,2,2,3).toArray(Integer[]::new);
\end{lstlisting}


\begin{comment}
	--- Generazione di stream
	Trattasi di un'operazione che applica un operatore unario ripetitivamente su un seme per creare uno stream
	Stream<T> iterate(T seed, UnaryOperator<T> generator)	// Ritorna un nuovo flusso con gli elementi generati.
	
	// Generazione infinita (stream lazy)
	Stream<Double> stream = Stream.generate(Math::random);
	List<Double> list = stream.toList();		// La computazione sarà infinita
	
	// Generazione controllata a partire da 0 con indice i, fintanto che i<10
	Stream<Integer> stream = Stream.iterate(0, i -> i+1).limit(10);
	List<Integer> list = stream.toList();	// La lista contiene i numeri da 0 a 9
	
	È possibile effettuare delle operazioni intermedie e terminali; le prime ritornano un nuovo Stream<T>, non modificano la fonte e possono essere concatenate con la notazione dot. Le seconde invece ritornano un risultato di un tipo specifico e ne è ammessa solo una.
	
	// Intermediate operations
	String[] arr = {"a", "b", "c", "d"};
	Stream<String> distinct = Arrays.stream(arr).distinct().sorted();	// Deduco le operazioni si facciano da sx a dx.
	long count = Arrays.stream(arr).distinct().count();
	
	Chiamiamo filtri le operazioni intermedie che applicano un predicato ad ogni elemento del flusso: Stream<T> filter(Predicate<T> predicate)
	
	// Lambda
	String[] arr = {"abc", "cde", "ecd", "cba"};
	Stream<String> stream = Arrays.strea,(arr).filter(s -> s.contains("d"));		// Il flusso conterrà le stringhe con la d
	
	// Method reference
	Character[] arr = {'a', '3', '7', 'd'};
	Stream<Character> stream = Arrays.stream(arr).filter(Character::isDigit);	// Il flusso conterrà 3 e 7
	
	// Metodi per filtraggio intermedio
	Stream<T> distinct()		// Scarta i duplicati
	Stream<T> limit(int n)	// Ritorna i primi n elementi
	Stream<T> skip(int n)	// Scarta i primi n elementi
	Stream<T> sorted()		// Ordina gli elementi per ordine naturale. T deve essere comparable
	
	// Map
	Operazione intermedia che applica una trasformazione agli elementi di uno stream
	Stream<R> map (Function<T,R> mapper)
	
	// Via lambda
	String[] arr = {"abc", "cdef", "ec", "cba"};
	Stream<Integer> stream = Arrays.stream(arr).map(s -> s.length());		// Lo stream contiene 3, 4, 2, 3
	
	// Via method reference
	String[] arr = {"aBc", "cd7f", "eC", "2Ba"};
	Stream<String> stream = Arrays.stream(arr).map(String::toUpperCase);		// Lo stream contiene ABC, CD7F, EC, 2BA
	
	Esistono operazioni terminali che applicano un predicato su un intero flusso. Queste si dicono Predicate Matching. Controllano:
	- Almeno un elemento matcha il predicato: boolean anyMatch(Predicate<T> predicate)
	- Tutti gli elementi matchano il predicato: boolean allMatch(Predicate<T> predicate)
	- Nessun elemento matcha il predicato: boolean noneMatch(Predicate<T> predicate)
	Altri invece:
	- Trovano il primo elemento dello stream, eventualmente che matcha un predicato: Optional<T> findFirst()
	- Trovano un elemento dello stream, eventualmente che matcha un predicato Optional<T> findAny()
	Eventualmente se non trovano nulla, ritornano un Optional vuoto. Optional è un valore potenziale.
	
	```Java
	Integer[] arr = {-1, 4, -5, 0, 3};
	Opional<Integer> opt = Arrays.stream(arr).filter(e -> e <= 0).findAny();
	
	// Controlla se un elemento è stato trovato
	if (opt.isPresent()) System.out.println(opt.get());
	else System.out.println(0);
	
	// Versione estremamente più compatta ed equivalente
	System.out.println(opt.orElse(0))
	
	--- Iterazione negli stream
	Trattasi di un'operazione terminale che itera (ma dai?) fra gli elementi del flusso. L'azione è eseguita su ogni elemento e lo stream viene consumato a fine operazione. Non dissimile dall'iterare una lista concatenata in C.
	
	```
	void forEach (Consumer<T> action)
	
	// Stampa gli elementi di un flusso
	Integer[] arr = {-1, 4, -5, 0, 3};
	Arrays.stream(arr).filter(e -> e <= 0).forEach(System.out::println);	// Haha method reference, ricordi?
	
	// Conta gli elementi di un flusso
	System.out.println(Arrays.stream(arr).filter(e -> e<= 0).count());
	```
	
	--- Flat map
	Operazione intermedia che estrae un flusso da ogni elemento dello stream dato come fonte.
	Stream<R> flatMap(Function<T, Stream<R>>, mapper)	// Trasforma valori T in vari stream di tipo R.
	
	La trasformazione è applicata ad ogni elemento, ed è ritornato un nuovo stream che concatena tutti gli stream appena creati. Tipicamente T in questo caso rappresenta più valori, tendenzialmente il suo ruolo è affidato ad una collezion.
\end{comment}

%

\section{java.io.*}
Il pacchetto java.io.* fornisce funzioni relative alla gestione di un flusso di dati, sia in input, che in output.

\begin{comment}
	--- Flussi di input/output
	Le operazioni di I/O dipendono dall'astrazione data dagli stream, che tuttavia in questi caso sono differenti dall'interfaccia Stream.
	Un flusso I/O può essere utilizzato con file statici sul disco, stdin, stdout, stderr, una connessione oppure un flusso di dati da oppure a dispositivi hardware. In ogni caso, i flussi operano allo stesso modo di quelli già affrontati.
	
	I flussi I/O sono contenuti nel pacchetto java.io, le cui relative eccezioni fanno parte di IOException. Fondamentalmente abbiamo due tipi di flussi che condividono la stessa interfaccia:
	```Java
	read()	// Ritorna uno o più byte/caratteri dallo stream
	write()	// Inserisce uno o più byte/caratteri nello stream
	close()	// Chiude lo stream
	```
	\begin{itemize}
		\item \textbf{Orientati ai Byte}: Flusso di Byte gestito da classi astratte InputStream e OutputStream, spesso usato per la gestione di dati in binario come immagini, audio o bytecode. Oltre al costruttore, che apre lo stream, presentano i seguenti metodi:
		Le implementazioni concrete sono specifiche del mezzo attraverso il quale si fa I/O e si utilizzano con le seguenti sottoclassi:
		\begin{itemize}
			\item BufferedInputStream/BufferedOutputStream: Legge/scrive dati con un buffer.
			\item DataInputStream/DataOutputStream: Legge/scrive tipi primitivi di Java
			\item FileInputStream/FileOutputStream: Legge/scrive un file.
		\end{itemize}
		\begin{lslisting}[language=Java]
			// Esempio di gestione IO con file binario
			public static void main (String args[]) throws IOException {
				FileInputStreamfis = null;
				FileOutputStreamfos = null;
				try {
					fis = new FileInputStream(args[0]);
					fos = new FileOutputStream(args[1]);
					int b;
					while ((b = fis.read()) != −1) {			// throws IOException
						fos.write(b);						// throws IOException
					}
				} catch (FileNotFoundException fnfe) {
					System.out.println("File not found...");
				} finally {
					if (fis != null) fis.close();			// throws IOException
					if (fos != null) fos.close();			// throws IOException
				}
			}
		\end{lslisting}
		\item \textbf{Orientati ai caratteri}: Flusso di caratteri Unicode a 16b gestito da classi astratte Reader e Writer, tendenzialmente usati per gestire dati testuali, come stringhe. Anche qui le implementazioni concrete dipendono dal mezzo e sono date dalle sottoclassi:
		\begin{itemize}
			\item BufferedReader/BufferedWriter: Leggi/Scrivi con un buffer
			\item InputStreamReader/OutputStreamWriter: Wrapper per leggere/scrivere da/a un mezzo basato su byte.
			\item StringReader/StringWriter: Wrapper per leggere/scrivere da/a una stringa.
			\item FileReader/FileWriter: Legge/scrive da/su un file.
		\end{itemize}
		\begin{lslisting}[language=Java]
			public static void main ( String args []) throws IOException
			Buffe redReade r br = null ;
			Buffe redWrite r bw = null ;
			try {
				br = new Buff eredRead er ( new FileReader ( " i . txt " ) ) ;
				bw = new Buff eredWrit er ( new FileWriter ( " o . txt " ) ) ;
				String line ;
				while (( line = br . readLine () ) != null ) {	// throws IOException
					bw . write ( line ) ;						// throws IOException
				}
			} catch ( F i l e N o t F o u n d E x c e p t i o n fnfe ) {
				System . out . println ( " File ␣ not ␣ found ... " ) ;
			} finally {
				if ( br != null ) br . close () ;				// throws IOException
				if ( bw != null ) bw . close () ;				// throws IOException
			}
		}
	\end{lslisting}
	\end{itemize}
	\noindent Attenzione che gli stream da java 7 si chiudono automaticamente con la IOException, quindi nella gestione si può omettere il metodo close().
	
	--- Files e URL
	In java.IO è presente anche la classe File, che permette la gestione di pathnames assolute e relative per la creazione di file e cartelle. Metodi utili:
	```
	create()
	delete()
	exists()
	renameTo()
	getParent()
	mkdir()
	getAbsolutePath()
	isFile()
	isDirectory()
	listFiles()
	```
	
	In sinergia, il pacchetto java.net porta la classe URL per la modellazione degli Uniform Resource Locator, che fungeranno da puntatori a risorse online.
	Gli URL si compongono di:
	\begin{itemize}
	\item protocollo: https://
	\item dominio: www.google.com
	\item port: :443
	\item path: /search
	\item parametri q=str&cr=countryIT
	\end{itemize}
	Il costruttore degli URL è deprecato, quindi vieve utilizzato il metodo .toURL().
\end{comment}