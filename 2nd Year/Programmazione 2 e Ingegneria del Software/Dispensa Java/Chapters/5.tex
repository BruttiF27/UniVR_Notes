\section{Libreria digitale}
Le librerie digitali di Java sono un insieme di funzioni contenute in \textbf{pacchetti} appositi e fornite da terze parti. Come altri utenti ne hanno scritte, così potremmo fare anche noi. In ogni caso, tutti i file da eseguire sono visti come classi, ed infatti dovranno essere compresi nel classpath, se non sono standard.\par
Per utilizzare una libreria è necessario importarla nel file desiderato con la keyword \textbf{import}. Per esempio, nella libreria java.util è presente la classe Scanner, che viene usata per ricevere input da tastiera.
\begin{lstlisting}[language=Java]
	// Aggiunge il pacchetto Scanner dal path java/util/Scanner
	import java.util.Scanner;
	
	public class Mult {
		public static void main(String args[]) {
			
			// Dichiarazione dell'oggetto keyScan di classe Scanner
			Scanner keyScan = new Scanner(System.in);
			int n1, n2;
			
			System.out.print("Inserisci il primo fattore: ");
			// Assegna a n1 l'intero letto da tastiera, idem n2.
			n1 = keyScan.nextInt();
			System.out.print("Inserisci il secondo fattore: ");
			n2 = keyScan.nextInt();
			
			// Chiudi lo scanner con il metodo close().
			keyScan.close();
			System.out.println("Risultato: " + n1*n2);
		}
	}
\end{lstlisting}
\noindent Quindi abbiamo capito che un pacchetto è un insieme di classi le quali sono logicamente correlate. Lo scopo principale è strutturare il codice in modo più chiaro grazie alla modularità che ne consegue. In termini più semplici, è considerabile come una libreria le cui interfacce sono date dalle classi.\par
I pacchetti possono essere innestati ed il path è dato dalla segnatura come visto nello snippet; i punti sostituiscono lo slash. In assenza di una dichiarazione del pacchetto, al file verrà associato quello di default, \textbf{package private}, il quale lo renderà inaccessibile da altri file. L'uso di quest'ultimo è sconsigliato e considerato cattiva pratica.\newline

\noindent La struttura dei pacchetti influenza anche la visibilità delle classi. Per esempio, supponiamo di avere un classpath di pacchetti "it.univr.bugs". Se inseriamo il main all'interno della directory univr e le classi funzionali all'interno di bugs, queste ultime non saranno visibili dalla prima; quindi è necessario importare il pacchetto con le modalità già viste.
\begin{lstlisting}[language=Java]
	package it.univr;	// Specifica del path corrente
	import it.univr.bugs.*;		// Per includere ogni classe
	import it.univr.bugs.Hornet;	// Per includere una classe specifica
\end{lstlisting}

%

\section{java.lang.*}
Il pacchetto java.lang.* comprende la libreria nativa del linguaggio, contenente tutte le funzioni di base come costrutti, oggetti e altri strumenti.

\subsection{Classi wrapper}
Le classi wrapper rappresentano sotto forma di classe i tipi primitivi. Sono compresi di campi e metodi per lavorare in un ambiente completamente orientato agli oggetti. Sono immutabili e si definiscono con lo stesso nome dei tipi primitivi, ma con la prima lettera maiuscola; abbiamo quindi: \textbf{Byte}, \textbf{Short}, \textbf{Integer}, \textbf{Long}, \textbf{Float}, \textbf{Double}, \textbf{Char} e \textbf{Boolean}.\par
Originalmente, per ottenere i valori da queste classi, era necessario fare wrapping e unwrapping coi relativi metodi, tuttavia, da Java 5, è stato implementato nel compilatore il concetto di \textbf{autoboxing} e \textbf{autounboxing}, consentendo di gestire le classi wrapper come si farebbe coi tipi primitivi.
\begin{lstlisting}[language=Java]
	Integer wi = 2;
	int j = 0;
	
	j = wi + 5;	// Sostituisce j = wi.intValue()+5;
	wi = 3;		// Sostituisce wi = new Integer(3);
	wi = j;		// Sostituisce wi = new Integer(j);
\end{lstlisting}
\noindent In particolare, la classe Character ha alcuni metodi statici di utility dal nome particolarmente esaustivo, come per esempio isLetter(), isDigit(), isSpaceChar(), toUpperCase(), toLowerCase() e altri.

\subsection{.System}
La classe System non può essere istanziata e comprende campi e metodi utili per la gestione di input/output standard e flusso. Dà inoltre accesso a proprietà esternamente definite e variabili di ambiente, permette di caricare file e librerie, ed infine un metodo di utility per copiare velocemente una porzione di array.
\begin{lstlisting}[language=Java]
	// Campi visti
	static PrintStream err		// stderr stream
	static InputStream in		// stdin stream
	static PrintStream out		// stdout stream
	
	// Metodi visti
	static long currentTimeMillis() // Ritorna l'ora attuale
\end{lstlisting}

\subsection{.String, .StringBuilder}
Le classi String, StringBuilder e StringJoiner sono utilizzate per la manipolazione di stringhe. Lavorano su oggetti immutabili. Le ultime due possono anche prendere delle stringhe già esistenti e convertirle in loro oggetti.
\begin{lstlisting}[language=Java]
	// Metodi visti - String
	String("Caratteri")		// Costruttore
	int length()			// Lunghezza della stringa
	char charAt(int index)		// Carattere a indice index
	int indexOf(int ch)		// ch in stringa? Y=indice/n=-1
	String substring(int beginIndex, int endIndex) // Ottiene substring
	String replace(char oldChar, char newChar) // Sostituisce old con new
	
	// Metodi visti - StringBuilder
	StringBuilder("Caratteri")	// Costruttore
	StringBuilder append("caratteri")	// Concatena alla stringa
	StringBuilder insert(int index, String str)	// inserisce str a partire da index
	StringBuilder delete(int beginIndex, int ednIndex) // Cancella caratteri negli indici
\end{lstlisting}

\subsection{.Math}
La classe Math non è istanziabile e contiene metodi per effettuare operazioni numeriche di base come esponenziali, logaritmi, radici e funzioni trigonometriche.
\begin{lstlisting}[language=Java]
	// Campi visti
	static double E		// 2.71
	static double PI	// 3.14
	
	// Metodi visti
	static int abs (int n)	// Valore assoluto di n
	static double log (double n)	// logaritmo in base e di n
	static double log10 (double n)	// logaritmo in base 10 di n
	static int max (int a, int b)	// Massimo fra a,b
	static int min (int a, int b) 	// Minimo fra a,b
	static long round (double d) 	// Approssimazione per ecc/dif
	static double sin (double r) 	// Seno di angolo r in radianti
	static double cos (double r) 	// Coseno di angolo r in radianti
	static double tan (double r) 	// Tangente di angolo r in radianti
	static double sqrt (double n) 	// Radice quadrata positiva di n
	static double toDegrees (double r) 	// Passa da rad a deg
	static double toRadians (double d) 	// Passa da deg a rad
\end{lstlisting}

\subsection{.Comparable, .Comparator}
L'interfaccia Comparable porta un metodo utile generalizzato per paragonare due oggetti.
\begin{lstlisting}[language=Java]
	// Negativo se this<obj, zero se this=obj e positivo se this>obj
	public int compareTo (T obj)
\end{lstlisting}
\noindent Esempio di utilizzo interfaccia Comparable mantenendo la sua logica facendo override del metoto compareTo:
\begin{lstlisting}[language=Java]
	public class Student extends Person implements Comparable {
		// ...
		@Override
		public int compareTo(Object obj) {
			Student other = (Student) obj;	// cast al tipo specifico
			return this.matricola - other.matricola;
		}
	}
\end{lstlisting}

\subsection{.Iterable, .Iterator}
Se una classe implementa l'interfaccia Iterable, i suoi oggetti potranno essere iterati con un ciclo for-each grazie al suo uso dell'interfaccia Iterator, parte del JCF, il quale sarà approfondito più avanti.
\begin{lstlisting}[language=Java]
	// Metodi visti
	boolean hasNext ()	// Vero se l'iterazione ha piu' elementi
	E next ()	// Torna il prossimo elemento
\end{lstlisting}
Esempio di utilizzo:\newline
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		import java.lang.Iterable;
		
		class ClassRoom implements Iterable {
			private Student[] students;
			
			ClassRoom(Student[] students) {
				this.students = students;
			}
			
			@Override
			public Iterator iterator () {
				return new CRIterator(students);
			}
		}
	\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		
		class CRIterator implements Iterator {
			private Student[] arr;
			private int next = 0;
		}
		
		CRIterator (Student[] arr) { this.arr = arr; }
		
		@Override
		public boolean hasNext () {
			return next < arr.length;
		}
		
		@Override
		public Object next () {
			return new Student(arr[next++]);
		}
	\end{lstlisting}
\end{minipage}
\begin{lstlisting}[language=Java]
	Student[] arrS = {new Student("Sam", 456), new Student("Paul", 123)};
	ClassRoom classRoom = new ClassRoom(arrS);
	
	for (Object obj:classRoom) {
		System.out.println(((Student)obj).toString)
	}
\end{lstlisting}

%

\section{java.util.*}
Il pacchetto java.util.* contiene varie funzioni di utility per rendere il codice più leggibile, astratto, modulare e sicuro.

\subsection{.Random}
La classe Random è istanziabile, ed è usata per la generazione di variabili pseudocasuali.
\begin{lstlisting}[language=Java]
	// Costruttori
	Random()
	Random(long seed)
	
	// Metodi
	boolean nextBoolean()	// Casuale true/false
	double nextDouble()		// Decimale fra [0.0, 1.0)
	float nextFloat()		// Decimale fra [0.0, 1.0)
	int nextInt()			// Casuale intero [-2^31, 2^31)
	int nextInt(int max)	// Casuale intero [0, max)
	long nextLong()			// Casuale intero [-2^63, 2^63)
\end{lstlisting}

\subsection{Java Collection Framework}
La Java Collection Framework è un insieme di strutture dati iterabili definite tramite l'uso di parametri generici, rendendole utilizzabili in qualunque contesto. Si tratta di uno dei pacchetti più importanti di tutto il linguaggio.\par
Tutte le strutture dati del framework estendono l'interfaccia padre \textbf{Collection}, la quale porta svariati metodi utili:
\begin{lstlisting}[language=Java]
	public interface Collection<E> extends Iterable<E> {
		int size ();
		int hasCode ();
		boolean equals (Object obj); // Notare equals non generic
		boolean isEmpty ();
		boolean contains (Object obj);
		boolean containsAll (Collection<?> c);
		boolean add (E e);
		boolean addAll (Collection<? extends E>);
		boolean remove (Object obj);
		boolean removeAll (Collection <?> c);
		void clear ();
		Object[] toArray ();
		Iterator<E> iterator (); // from Iterable<E>
	}
\end{lstlisting}
\noindent le strutture dati sottoclassi di Collection si riassumono in tre macrocategorie, date da:
\begin{itemize}
	\item \textbf{List}: Una lista di elementi, la quale può avere duplicati e dove si mantiene l'ordine di inserimento. Sottoclassi sono \textbf{ArrayList} e \textbf{LinkedList}.
	\item \textbf{Queue}: Una lista di elementi legati da una relazione di ordinamento. Sottoclassi sono \textbf{Dequeue} e \textbf{PriorityQueue}.
	\item \textbf{Set}: Insieme di elementi unici. Sottoclasse è \textbf{HashSet}.
\end{itemize}
\noindent Il modo corretto per la dichiarazione di queste strutture è istanziare la sottoclasse a partire dalla sovracclasse, funzionale grazie al principio di sostituzione.
\begin{lstlisting}[language=Java]
	// Esempio di implementazione
	Collection<Person> list = new LinkedList<>();	// Crea lista
	list.add(new Person("Joe"));	// Aggiunge Joe in coda alla lista
	list.add(new Person("Sam"));
\end{lstlisting}
\noindent Naturalmente ogni struttura avrà metodi per facilitarne il workflow. Abbiamo un insieme di metodi condivisi fra List e Queue, mentre per Set sono sufficienti quelli ereditati da Collection.
\begin{lstlisting}[language=Java]
	// Metodi per List e Queue
	E get (int i);	// Ottieni l'elemento a posizione i
	E set(int i, E e);	// Rimpiazza l'elemento e a posizione i
	void set(int i, E e);	// Aggiungi elemento e a posizione i
	E remove(int i);	// Rimuovi elemento a posizione i
	int indexOf(E e);	// Ritorna la posizione dell'elemento e
	List<E> subList(int l, int r);	// Ritorna lista fra gli indici [l,r)
\end{lstlisting}
\noindent Un'utile implementazione di Set si ha con la sua sottoclasse \textbf{HashSet}, la quale consente l'accesso agli elementi della struttura a tempo costante in base a una determinata chiave. Questa struttura dati mantiene ineternalmente una HashMap, la quale garantisce l'unicità degli elementi usando il loro \textbf{hashcode} come chiave.\par
Per una corretta generazione del codice si deve usare il metodo \textbf{hash(obj1, obj2)}, dato dalla classe Object, per poi fare override di equals() con lo scopo di basarlo sulla chiave. Un'altra implementazione utile di Set è \textbf{TreeSet}, basata sulla logica degli RB-Alberi. Aggiunge i metodi first() e last() per prendere il nodo radice e l'ultimo del cammino rispettivamente.\newline

\noindent Un'ultima struttura sempre facente parte del JCF ma non ereditante Collection è la \textbf{Map<K, V>}, dove K sta per key e V per value. Si tratta di un insieme di associazioni che collegano una specifica chiave ad un determinato valore. Capirai che Set e Map sono strettamente legati. Presenta i seguenti metodi:
\begin{lstlisting}[language=Java]
	V put(K key, V values);	// Inserisci associamento
	V get(Object key);	// Torna il valore associato alla chiave
	V remove(Object key);	// Rimuovi l'associamento della chiave
	boolean containsKey(Object key);	// Vedi se la mappa ha una chiave
	boolean containsValue(Object value);	// Torna se valore in mappa
	Set<K> keySet();	// Ritorna le chiavi della mappa
	Collection<V> values();	// Ritorna i valori nella mappa
\end{lstlisting}
\noindent La JCF rende il il codice estremamente standardizzato; tuttavia non basta creare gli oggetti, bisogna anche poterci lavorare.\par
Le mansioni principali sono quelle di scorrere gli elementi e il loro ordinamento; questo lavoro è reso semplice grazie alla sinergia con le interfacce Iterable e Comparable e di conseguenza anche con Iterator e Comparator.

\subsection{Interfacce funzionali primitive}
Le interfacce funzionali sono un argomento già menzionato nei capitoli precedenti, tuttavia è possibile usufruire delle loro versioni base e di uso comune definite in questo pacchetto, date da:\newline

\noindent \textbf{- Predicate}\par
\noindent Prende un parametro di tipo T e ritorna un boolean. Viene spesso usato per filtrare elementi in una collection.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Predicate<T> {
		boolean test(T t);	// Qui T e' generics, ma puo' essere specificato
	}
	
	// Versione semplice
	Predicate<Integer> isEven = new Predicate<>() {
		@Override
		public boolean test(Integer n) { return n%2 == 0; }
	}
	
	// Versione lambda
	Predicate<Integer> isEven = n -> n%2 == 0;
	
	System.out.println(isEven.test(2)); // true
	System.out.println(isEven.test(3)); // false
\end{lstlisting}
\noindent \textbf{- Function}\par
\noindent Prende un parametro di tipo T e ritorna un risultato di tipo R. Spesso usato per mappare un valore ad un altro.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Function<T, R> {
		R apply(T t);
	}
	
	// Function strLen prende String e ritorna Integer
	Function<String, Integer> strLen = str -> str.length();
	
	Systm.out.println(strLen.apply("Hello"));	// Qua stampa 5
\end{lstlisting}
\noindent \textbf{- BiPredicate}\par
\noindent Prende due parametri di tipi T e U per ritornare un boolean
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface BiPredicate<T, U> {
		boolean test(T t, U u);
	}
	
	// La lambda isGreaterThan prende i due parametri e ritorna se la condizione e' vera
	BiPredicate<Integer, Integer> isGreaterThan = (a,b) -> a > b
	
	System.out.println(isGreaterThan.test(2, 5)); // false
	System.out.println(isGreaterThan.test(3, 1)); // true
\end{lstlisting}
\noindent \textbf{- BiFunction}\par
\noindent Prende due parametri di tipi T, U e ritorna un risultato di tipo R, spesso usata per implementare operazioni su due valori.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface BiFunction<T, U, R> {
		R apply(T t, U u);
	}
	
	BiFunction<Integer, Integer, Integer> sumInt = (a,b) -> a+b;
	
	System.out.println(sumInt.apply(3,9));	// Stampa 12
\end{lstlisting}
\noindent \textbf{- Consumer}\par
\noindent Prende un parametro di tipo T e non ritorna niente. Spesso usata per modellare effetti collaterali.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Consumer<T> {
		void accept(T t);
	}
	
	// La lambda ha un effetto sull'argomento, ma non ritorna nulla
	Consumer<String> printUC = str -> System.out.println(str.toUpperCase());
	
	printUC.accept("string");	// Stampa STRING
\end{lstlisting}
\noindent \textbf{- Supplier}\par
\noindent Funzione che non prende parametri ma ritorna un valore di tipo T; spesso usata per la generazione di valori
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Supplier<T> {
		T get();
	}
	
	Supplier<Double> randomNum = () -> Math.random();
	System.out.println(randomNum.get());		// Stampa il numero casuale
\end{lstlisting}
\noindent Ulteriori interfacce funzionali sono date da: \begin{center}
	\textbf{UnaryOperator<T>} extends Function<T, T>, \textbf{BinaryOperator<T>} extends BiFunction<T, T, T>
\end{center}
\noindent Dove la prima prende un parametro T per ritornarne un altro, mentre la seconda ne prende due di tipo T per ritornarne un terzo. Esiste infine una sintassi compatta per fare method reference:
\begin{lstlisting}[language=Java]
	// Sintassi compatta
	System.out::println
	// Equivale a
	str -> System.out.println(str)
\end{lstlisting}
\noindent Generalmente, valgono queste regole:
\begin{itemize}
	\item Per metodi statici: Class::staticMethod
	\item Per metodi d'istanza: object::instanceMethod
	\item Per metodi non statici: Class::nonStaticMethod
	\item Per il costruttore: Class::new
\end{itemize}	

\subsection{.Stream}
Da Java8, il pacchetto java.util.stream contiene classi apposite per processare i flussi di dati. Un flusso è una sequenza di elementi di una fonte e si definisce con la classe \textbf{Stream<T>}. La sequenza supporta operazioni di processione dati, definite tramite interfacce funzionali. I flussi hanno nativamente pipelining, iterazioni interne e parallelizzazioni. Alcuni utilizzi comuni sono:
\begin{lstlisting}[language=Java]
	// Stream.of(T... elems) scorre ogni elemento dato come parametro.
	Stream<String> stream = Stream.of("a", "b", "c");
	
	// Arrays.stream(T[] arr) scorre ogni elemento di un dato array.
	String[] arr = new String[] {"d", "e", "f"};
	Stream<String> stream = Arrays.stream(arr);
	
	// Collection.stream() scorre ogni elemento di una collezione del JCF
	Set<String> set = Set.of("g", "h", "i");
	Stream<String> stream = set.stream();
	
	// Crea una lista a partire dallo stream
	List<Integer> list = Stream.of(1, 2, 2, 3).toList(); 
	
	// Crea un set a partire dallo stream
	Set<Integer> set = Stream.of(1, 2, 2, 3).collect(Collectors.toSet()); 
	
	// Crea un array a partire dallo stream
	Integer[] arr = Stream.of(1,2,2,3).toArray(Integer[]::new);
\end{lstlisting}
\noindent È possibile generare degli stream di vario tipo. Parliamo di un'operazione che applica un operatore unario ripetitivamente su un dato seme, la cui segnatura è data da: \begin{center}
	Stream<T> iterate(T seed, UnaryOperator<T> generator)
\end{center}
\noindent Questo metodo ritornerà un nuovo flusso con gli elementi generati. Abbiamo altre tecniche come:
\begin{lstlisting}[language=Java]
	// Generazione infinita (stream lazy)
	Stream<Double> stream = Stream.generate(Math::random);
	// La computazione sara' infinita
	List<Double> list = stream.toList();
	
	// Generazione controllata da 0 con indice i, fintanto che i<10
	Stream<Integer> stream = Stream.iterate(0, i -> i+1).limit(10);
	// La lista contiene i numeri da 0 a 9
	List<Integer> list = stream.toList();
\end{lstlisting}
\noindent Possiamo inoltre effettuare delle operazioni \textbf{intermedie} e \textbf{terminali}; le prime ritornano un nuovo Stream<T>, non modificano la fonte e possono essere concatenate con la notazione dot, mentre le seconde ritornano un risultato di un tipo specifico e ne è ammessa solo una. Per esempio:
\begin{lstlisting}[language=Java]
	String[] arr = {"a", "b", "c", "d"};
	
	// Ritorna lo stream distinct da fonte arr senza duplicati e ordinata.
	Stream<String> distinct = Arrays.stream(arr).distinct().sorted();
	
	// Ritorna il totale degli elementi di arr distinti
	long count = Arrays.stream(arr).distinct().count();
\end{lstlisting}
\noindent Un concetto più raffinato di questo algoritmo si ha con i \textbf{filtri}, operazioni intermedie che applicano un predicato ad ogni elemento del flusso; hanno segnatura: \begin{center}
	Stream<T> filter(Predicate<T> predicate)
\end{center}
\begin{lstlisting}[language=Java]
	// Via lambda
	String[] arr = {"abc", "cde", "ecd", "cba"};
	// stream conterra' le stringhe con la d
	Stream<String> stream = Arrays.stream(arr)
		.filter(s -> s.contains("d"));
	
	// Via method reference
	Character[] arr = {'a', '3', '7', 'd'};
	// stream conterra' i caratteri 3 e 7
	Stream<Character> stream = Arrays.stream(arr)
		.filter(Character::isDigit);
\end{lstlisting}
\noindent Generalmente, vengono usati spesso i seguenti metodi per filtraggio intermedio:
\begin{lstlisting}[language=Java]
	// Ritorna lo stream scartando i duplicati
	Stream<T> distinct();
	// Ritorna i primi n elementi
	Stream<T> limit(int n);	
	// Scarta i primi n elementi e ritorna i successivi
	Stream<T> skip(int n);
	// Ordina gli elementi per ordine naturale. T deve essere comparable
	Stream<T> sorted();
\end{lstlisting}
\noindent Naturalmente consegue che se è possibile filtrare degli elementi specifici, possiamo anche eseguire delle operazioni o trasformazioni su di essi. Ciò avviene grazie al metodo \textbf{map()}, di segnatura: \begin{center}
	Stream<R> map (Function<T,R> mapper)
\end{center}
\begin{lstlisting}[language=Java]
	// Via lambda
	String[] arr = {"abc", "cdef", "ec", "cba"};
	// stream contiene 3, 4, 2, 3
	Stream<Integer> stream = Arrays.stream(arr).map(s -> s.length());
	
	// Via method reference
	String[] arr = {"aBc", "cd7f", "eC", "2Ba"};
	// Lo stream contiene ABC, CD7F, EC, 2BA
	Stream<String> stream = Arrays.stream(arr).map(String::toUpperCase);
\end{lstlisting}
\noindent Quando parliamo di operazioni terminali, invece, ribadisco, si attuano sull'intero flusso e non lo ritornano. Metodi di uso comune sono:
\begin{lstlisting}[language=Java]
	// Controlla se almeno un elemento matcha il predicato
	boolean anyMatch(Predicate<T> predicate);
	// Controlla che tutti gli elementi matchino il predicato
	boolean allMatch(Predicate<T> predicate);
	// Controlla che nessun elemento matchi il predicato
	boolean noneMatch(Predicate<T> predicate);
	// Trova il primo elemento dello stream che matcha un predicato
	Optional<T> findFirst();
	// Trova un elemento dello stream che matcha un predicato
	Optional<T> findAny()
\end{lstlisting}
\noindent In questo ambito esiste il metodo \textbf{orElse()} che mostra una scrittura più compatta al posto di usare un costrutto condizionale:
\begin{lstlisting}[language=Java]
	// Salva in opt un elemento e minore o uguale a 0
	Integer[] arr = {-1, 4, -5, 0, 3};
	Opional<Integer> opt = Arrays.stream(arr)
		.filter(e -> e <= 0).findAny();
	
	// Stampa opt se non e' null, altrimenti stampa 0
	System.out.println(opt.orElse(0));
	
	/* Scrittura equivalente a quanto segue:
	 * if (opt.isPresent()) System.out.println(opt.get());
	 * else System.out.println(0);
	 */
\end{lstlisting}
\noindent Possiamo inoltre iterare fra gli elementi del flusso. È un'azione eseguita su ogni singolo elemento e lo stream viene \textbf{consumato} a fine operazione. Segnatura: \begin{center}
	void forEach (Consumer<T> action)
\end{center}
\begin{lstlisting}[language=Java]
	// Stampa gli elementi di un flusso
	Integer[] arr = {-1, 4, -5, 0, 3};
	Arrays.stream(arr).filter(e -> e <= 0).forEach(System.out::println);
	
	// Conta gli elementi di un flusso
	System.out.println(Arrays.stream(arr).filter(e -> e<= 0).count());
\end{lstlisting}
\noindent Infine, esiste un'operazione intermedia che estrae un flusso da ogni elemento dello stream dato come fonte, chiamata \textbf{flatMap()}, con segnatura: \begin{center}
	Stream<R> flatMap(Function<T, Stream<R>>, mapper)
\end{center}
\noindent Quindi si effettua una trasformazione per ogni elemento T, il quale viene poi ritornato come singolo flusso. Questi ultimi saranno concatenati e poi ritornati come un singolo Stream di tipo R. Tipicamente, come è facile dedurre, T rappresenta più valori e il ruolo dello stream finale è tendenzialmente affidato ad una Collection.
\begin{lstlisting}[language=Java]
	// Caso di uso con array
	Byte[][] arr ={{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
	
	// stream contiene 1, 2, 3, 4, 5, 6, 7, 8, 9
	Stream<Byte> stream = Arrays.stream(arr)
		.flatMap(r -> Arrays.stream(r));
\end{lstlisting}
\begin{lstlisting}[language=Java]
	// Caso di uso con Collection
	List<List<Integer>> list = new LinkedList<>();
	list.add(new LinkedList<>()); list.add(new LinkedList<>());
	
	// Aggiungi cifre a posizione get(i)
	list.get(0).add(1); list.get(0).add(3);
	list.get(1).add(7);	list.get(1).add(9);
	
	// stream contiene 1, 3, 7, 9
	Stream<Integer> stream = list.stream().flatMap(Collection::stream);
\end{lstlisting}
\begin{lstlisting}[language=Java]
	// Scrittura ulteriormente concatenata
	Integer[][] arr = {{1, -2, 3}, {4, -5, -6}, {-7, -8, 9}};
	
	Arrays.stream(arr)
		.flatMap(Arrays::stream)
		.filter(i -> i > 0)
		.map(i -> String.format("%d is positive", i))
		.forEach(System.out::println);
	
	/* output risultante:
	 * '1 is positive'
	 * '3 is positive'
	 * '4 is positive'
	 * '9 is positive'
	 */
\end{lstlisting}

%

\section{java.io.*}
Il pacchetto java.io.* fornisce classi ed eccezioni relative alla gestione di un flusso di dati, sia in input, che in output. In particolare, le operazioni dipendono da un'astrazione simil-stream, la quale, sebbene funzioni allo stesso modo dei metodi dell'interfaccia Stream, non ne fa alcun utilizzo.\par
I flussi di I/O possono essere utilizzati con file statici sul disco, standard input, standard output, standard error, una connessione oppure uno stream di dati da/a dispositivi hardware; come vedremo, esistono due tipi di stream con i quali possiamo lavorare e condivisono i seguenti metodi:\begin{itemize}
	\item \textbf{read()}: Ritorna uno o più byte/caratteri dallo stream.
	\item \textbf{write()}: Inserisce uno o più byte/caratteri nello stream.
	\item \textbf{close()}: Chiude lo stream.
\end{itemize}

\noindent\textbf{- Flussi orientati ai Byte}\par
\noindent Flusso di Byte gestito dalle classi astratte \textbf{InputStream} e \textbf{OutputStream}, spesso usato per la gestione di dati in binario come immagini, audio o bytecode. Oltre al costruttore, che apre lo stream, presentano i seguenti metodi, le cui implementazioni concrete sono specifiche del mezzo attraverso il quale si fa I/O e si definiscono con le seguenti sottoclassi:
\begin{itemize}
	\item \textbf{BufferedInputStream/BufferedOutputStream}: Legge/scrive dati con buffer.
	\item \textbf{DataInputStream/DataOutputStream}: Legge/scrive tipi primitivi di Java.
	\item \textbf{FileInputStream/FileOutputStream}: Legge/scrive un file.
\end{itemize}
\begin{lstlisting}[language=Java]
	// Esempio di gestione IO con file binario
	public static void main (String args[]) throws IOException {
		
		FileInputStreamfis = null;
		FileOutputStreamfos = null;
		
		try {
			fis = new FileInputStream(args[0]);
			fos = new FileOutputStream(args[1]);
			int b;
			while ((b = fis.read()) != -1) {		// lancia IOException
				fos.write(b);						// lancia IOException
			}
		} catch (FileNotFoundException fnfe) {
			System.out.println("File not found...");
		} finally {
			if (fis != null) fis.close();			// lancia IOException
			if (fos != null) fos.close();			// lancia IOException
		}
	}
\end{lstlisting}
\noindent\textbf{- Flussi orientati ai caratteri}\par
\noindent Flusso di caratteri Unicode a 16b gestito dalle classi astratte \textbf{Reader} e \textbf{Writer}, tendenzialmente usato per gestire dati testuali, come stringhe. Anche qui le implementazioni concrete dipendono dal mezzo e sono date dalle seguenti sottoclassi: \begin{itemize}
	\item \textbf{BufferedReader/BufferedWriter}: Leggi/Scrivi con buffer.
	\item \textbf{InputStreamReader/OutputStreamWriter}: Wrapper per leggere/scrivere da/a un mezzo basato su byte.
	\item \textbf{StringReader/StringWriter}: Wrapper per leggere/scrivere da/a una stringa.
	\item \textbf{FileReader/FileWriter}: Legge/scrive da/su un file.
\end{itemize}
\begin{lstlisting}[language=Java]
	// Esempio di gestione IO con file testuale
	public static void main (String[] args) throws IOException {
		
		BufferedReader br = null;
		BufferedWriter bw = null;
		
		try {
			br = new BufferedReader(new FileReader("i.txt"));
			bw = new BufferedWriter(new FileWriter("o.txt"));
			String line;
			while ((line = br.readLine()) != null) {	// Lancia IOException
				bw.write(line);							// Lancia IOException
			}
		} catch (FileNotFoundException fnfe) {
			System.out.println("File not found");
		} finally {
			if (br != null) br.close();					// Lancia IOException
			if (bw != null) bw.close();					// Lancia IOException
		}
	}
\end{lstlisting}
\noindent Attenzione: gli stream da Java 7 si chiudono automaticamente con la IOException, quindi nella gestione si può omettere il metodo close(). In qualunque altro caso, vanno manualmente chiusi.\par
Naturalmente, è possibile istanziare degli oggetti di classe \textbf{File}, la quale ha metodi che permettono di gestire di pathnames assoluti e relativi per la creazione di file e cartelle:
\begin{lstlisting}[language=Java]
	boolean createNewFile()		// Crea un file vuoto con relativo pathname
	boolean delete()			// Elimina un file con relativo pathname
	boolean exists()			// Controlla se un file esiste nella directory
	boolean renameTo(File dest)	// Rinomina un file col pathname di dest
	String getParent()			// Ritorna la stringa di pathname del file
	boolean mkdir()				// Crea una cartella con un dato pathname
	String getAbsolutePath()	// Ritorna il path assoluto
	boolean isFile()			// Controlla se l'oggetto e' un file
	boolean isDirectory()		// Controlla se l'oggetto e' una cartella
	File[] listFiles()			// Ritorna un array di pathnames astratti corrispondenti ai file
\end{lstlisting}
\noindent In perfetta sinergia, il pacchetto java.net porta la classe \textbf{URL} per la modellazione degli Uniform Resource Locator, che fungeranno da puntatori a risorse online.	Questi si compongono di:
\begin{itemize}
	\item protocollo: https://
	\item dominio: www.google.com
	\item port: :443
	\item path: /search
	\item parametri q=str\&cr=countryIT
\end{itemize}
\noindent Attenzione, il costruttore degli URL è deprecato, quindi nell'istanziazione di oggetti va utilizzato il metodo \textbf{toURL()}, come segue:
\begin{lstlisting}[language=Java]
	try {
		URL www = new URI("http://info.cern.ch/index.html").toURL();
		BufferedInputStream in = new BufferedInputStream(www.openStream());
		byte[] dataBuffer = new byte [1024];
		
		while (in.read(dataBuffer, 0, 1024) != -1) {
			System.out.println(new String(dataBuffer));
		}
	} catch (IOException | URISyntaxException e) throw new RuntimeException(e);
\end{lstlisting}