\section{Libreria digitale}
Le librerie digitali di Java sono un insieme di funzioni contenute in \textbf{pacchetti} appositi e fornite da terze parti. Come altri utenti ne hanno scritte, così potremmo fare anche noi. In ogni caso, tutti i file da eseguire sono visti come classi, ed infatti dovranno essere compresi nel classpath, se non sono standard.\par
Per utilizzare una libreria è necessario importarla nel file desiderato con la keyword \textbf{import}. Per esempio, nella libreria java.util è presente la classe Scanner, che viene usata per ricevere input da tastiera.
\begin{lstlisting}[language=Java]
	// Aggiunge il pacchetto Scanner dal path java/util/Scanner
	import java.util.Scanner;
	
	public class Mult {
		public static void main(String args[]) {
			
			// Dichiarazione dell'oggetto keyScan di classe Scanner
			Scanner keyScan = new Scanner(System.in);
			int n1, n2;
			
			System.out.print("Inserisci il primo fattore: ");
			// Assegna a n1 l'intero letto da tastiera, idem n2.
			n1 = keyScan.nextInt();
			System.out.print("Inserisci il secondo fattore: ");
			n2 = keyScan.nextInt();
			
			// Chiudi lo scanner con il metodo close().
			keyScan.close();
			System.out.println("Risultato: " + n1*n2);
		}
	}
\end{lstlisting}
\noindent Quindi abbiamo capito che un pacchetto è un insieme di classi le quali sono logicamente correlate. Lo scopo principale è strutturare il codice in modo più chiaro grazie alla modularità che ne consegue. In termini più semplici, è considerabile come una libreria le cui interfacce sono date dalle classi.\par
I pacchetti possono essere innestati ed il path è dato dalla segnatura come visto nello snippet; i punti sostituiscono lo slash. In assenza di una dichiarazione del pacchetto, al file verrà associato quello di default, \textbf{package private}, il quale lo renderà inaccessibile da altri file. L'uso di quest'ultimo è sconsigliato e considerato cattiva pratica.\newline

\noindent La struttura dei pacchetti influenza anche la visibilità delle classi. Per esempio, supponiamo di avere un classpath di pacchetti "it.univr.bugs". Se inseriamo il main all'interno della directory univr e le classi funzionali all'interno di bugs, queste ultime non saranno visibili dalla prima; quindi è necessario importare il pacchetto con le modalità già viste.
\begin{lstlisting}[language=Java]
	package it.univr;	// Specifica del path corrente
	import it.univr.bugs.*;		// Per includere ogni classe
	import it.univr.bugs.Hornet;	// Per includere una classe specifica
\end{lstlisting}

%

\section{java.lang.*}
Il pacchetto java.lang.* comprende la libreria nativa del linguaggio, contenente tutte le funzioni di base come costrutti, oggetti e altri strumenti.

\subsection{Classi wrapper}
Le classi wrapper rappresentano sotto forma di classe i tipi primitivi. Sono compresi di campi e metodi per lavorare in un ambiente completamente orientato agli oggetti. Sono immutabili e si definiscono con lo stesso nome dei tipi primitivi, ma con la prima lettera maiuscola; abbiamo quindi: \textbf{Byte}, \textbf{Short}, \textbf{Integer}, \textbf{Long}, \textbf{Float}, \textbf{Double}, \textbf{Char} e \textbf{Boolean}.\par
Originalmente, per ottenere i valori da queste classi, era necessario fare wrapping e unwrapping coi relativi metodi, tuttavia, da Java 5, è stato implementato nel compilatore il concetto di \textbf{autoboxing} e \textbf{autounboxing}, consentendo di gestire le classi wrapper come si farebbe coi tipi primitivi.
\begin{lstlisting}[language=Java]
	Integer wi = 2;
	int j = 0;
	
	j = wi + 5;	// Sostituisce j = wi.intValue()+5;
	wi = 3;		// Sostituisce wi = new Integer(3);
	wi = j;		// Sostituisce wi = new Integer(j);
\end{lstlisting}
\noindent In particolare, la classe Character ha alcuni metodi statici di utility dal nome particolarmente esaustivo, come per esempio isLetter(), isDigit(), isSpaceChar(), toUpperCase(), toLowerCase() e altri.

\subsection{.System}
La classe System non può essere istanziata e comprende campi e metodi utili per la gestione di input/output standard e flusso. Dà inoltre accesso a proprietà esternamente definite e variabili di ambiente, permette di caricare file e librerie, ed infine un metodo di utility per copiare velocemente una porzione di array.
\begin{lstlisting}[language=Java]
	// Campi visti
	static PrintStream err		// stderr stream
	static InputStream in		// stdin stream
	static PrintStream out		// stdout stream
	
	// Metodi visti
	static long currentTimeMillis() // Ritorna l'ora attuale
\end{lstlisting}

\subsection{.String, .StringBuilder}
Le classi String, StringBuilder e StringJoiner sono utilizzate per la manipolazione di stringhe. Lavorano su oggetti immutabili. Le ultime due possono anche prendere delle stringhe già esistenti e convertirle in loro oggetti.
\begin{lstlisting}[language=Java]
	// Metodi visti - String
	String("Caratteri")		// Costruttore
	int length()			// Lunghezza della stringa
	char charAt(int index)		// Carattere a indice index
	int indexOf(int ch)		// ch in stringa? Y=indice/n=-1
	String substring(int beginIndex, int endIndex) // Ottiene substring
	String replace(char oldChar, char newChar) // Sostituisce old con new
	
	// Metodi visti - StringBuilder
	StringBuilder("Caratteri")	// Costruttore
	StringBuilder append("caratteri")	// Concatena alla stringa
	StringBuilder insert(int index, String str)	// inserisce str a partire da index
	StringBuilder delete(int beginIndex, int ednIndex) // Cancella caratteri negli indici
\end{lstlisting}

\subsection{.Math}
La classe Math non è istanziabile e contiene metodi per effettuare operazioni numeriche di base come esponenziali, logaritmi, radici e funzioni trigonometriche.
\begin{lstlisting}[language=Java]
	// Campi visti
	static double E		// 2.71
	static double PI	// 3.14
	
	// Metodi visti
	static int abs (int n)	// Valore assoluto di n
	static double log (double n)	// logaritmo in base e di n
	static double log10 (double n)	// logaritmo in base 10 di n
	static int max (int a, int b)	// Massimo fra a,b
	static int min (int a, int b) 	// Minimo fra a,b
	static long round (double d) 	// Approssimazione per ecc/dif
	static double sin (double r) 	// Seno di angolo r in radianti
	static double cos (double r) 	// Coseno di angolo r in radianti
	static double tan (double r) 	// Tangente di angolo r in radianti
	static double sqrt (double n) 	// Radice quadrata positiva di n
	static double toDegrees (double r) 	// Passa da rad a deg
	static double toRadians (double d) 	// Passa da deg a rad
\end{lstlisting}

\subsection{.Comparable, .Comparator}
L'interfaccia Comparable porta un metodo utile generalizzato per paragonare due oggetti.
\begin{lstlisting}[language=Java]
	// Negativo se this<obj, zero se this=obj e positivo se this>obj
	public int compareTo (T obj)
\end{lstlisting}
\noindent Esempio di utilizzo interfaccia Comparable mantenendo la sua logica facendo override del metoto compareTo:
\begin{lstlisting}[language=Java]
	public class Student extends Person implements Comparable {
		// ...
		@Override
		public int compareTo(Object obj) {
			Student other = (Student) obj;	// cast al tipo specifico
			return this.matricola - other.matricola;
		}
	}
\end{lstlisting}

\subsection{.Iterable, .Iterator}
Se una classe implementa l'interfaccia Iterable, i suoi oggetti potranno essere iterati con un ciclo for-each grazie al suo uso dell'interfaccia Iterator, parte del JCF, il quale sarà approfondito più avanti.
\begin{lstlisting}[language=Java]
	// Metodi visti
	boolean hasNext ()	// Vero se l'iterazione ha piu' elementi
	E next ()	// Torna il prossimo elemento
\end{lstlisting}
Esempio di utilizzo:\newline
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		import java.lang.Iterable;
		
		class ClassRoom implements Iterable {
			private Student[] students;
			
			ClassRoom(Student[] students) {
				this.students = students;
			}
			
			@Override
			public Iterator iterator () {
				return new CRIterator(students);
			}
		}
	\end{lstlisting}
\end{minipage}
\begin{minipage}{0.5\linewidth}
	\begin{lstlisting}[language=Java]
		import java.util.Iterator;
		
		class CRIterator implements Iterator {
			private Student[] arr;
			private int next = 0;
		}
		
		CRIterator (Student[] arr) { this.arr = arr; }
		
		@Override
		public boolean hasNext () {
			return next < arr.length;
		}
		
		@Override
		public Object next () {
			return new Student(arr[next++]);
		}
	\end{lstlisting}
\end{minipage}
\begin{lstlisting}[language=Java]
	Student[] arrS = {new Student("Sam", 456), new Student("Paul", 123)};
	ClassRoom classRoom = new ClassRoom(arrS);
	
	for (Object obj:classRoom) {
		System.out.println(((Student)obj).toString)
	}
\end{lstlisting}



\begin{comment}
	\subsection{.AutoCloseable}
	\subsection{.Thread}
\end{comment}

%

\section{java.util.*}
Il pacchetto java.util.* contiene varie funzioni di utility per rendere il codice più leggibile, astratto, modulare e sicuro.
\subsection{.Scanner}
netxLine, nextInt, nextFloat

\subsection{.Random}
La classe Random è istanziabile, ed è usata per la generazione di variabili pseudocasuali.
\begin{lstlisting}[language=Java]
	// Costruttori
	Random()
	Random(long seed)
	
	// Metodi
	boolean nextBoolean()	// Casuale true/false
	double nextDouble()		// Decimale fra [0.0, 1.0)
	float nextFloat()		// Decimale fra [0.0, 1.0)
	int nextInt()			// Casuale intero [-2^31, 2^31)
	int nextInt(int max)	// Casuale intero [0, max)
	long nextLong()			// Casuale intero [-2^63, 2^63)
\end{lstlisting}

\subsection{.Arrays}

\subsection{Java Collection Framework}
La Java Collection Framework è un insieme di strutture dati iterabili definite tramite l'uso di parametri generici, rendendole utilizzabili in qualunque contesto. Si tratta di uno dei pacchetti più importanti di tutto il linguaggio.\par
Tutte le strutture dati del framework estendono l'interfaccia padre \textbf{Collection}, la quale porta svariati metodi utili:
\begin{lstlisting}[language=Java]
	public interface Collection<E> extends Iterable<E> {
		int size ();
		int hasCode ();
		boolean equals (Object obj); // Notare equals non generic
		boolean isEmpty ();
		boolean contains (Object obj);
		boolean containsAll (Collection<?> c);
		boolean add (E e);
		boolean addAll (Collection<? extends E>);
		boolean remove (Object obj);
		boolean removeAll (Collection <?> c);
		void clear ();
		Object[] toArray ();
		Iterator<E> iterator (); // from Iterable<E>
	}
\end{lstlisting}
\noindent le strutture dati sottoclassi di Collection si riassumono in tre macrocategorie, date da:
\begin{itemize}
	\item \textbf{List}: Una lista di elementi, la quale può avere duplicati e dove si mantiene l'ordine di inserimento. Sottoclassi sono \textbf{ArrayList} e \textbf{LinkedList}.
	\item \textbf{Queue}: Una lista di elementi legati da una relazione di ordinamento. Sottoclassi sono \textbf{Dequeue} e \textbf{PriorityQueue}.
	\item \textbf{Set}: Insieme di elementi unici. Sottoclasse è \textbf{HashSet}.
\end{itemize}
\noindent Il modo corretto per la dichiarazione di queste strutture è istanziare la sottoclasse a partire dalla sovracclasse, funzionale grazie al principio di sostituzione.
\begin{lstlisting}[language=Java]
	// Esempio di implementazione
	Collection<Person> list = new LinkedList<>();	// Crea lista
	list.add(new Person("Joe"));	// Aggiunge Joe in coda alla lista
	list.add(new Person("Sam"));
\end{lstlisting}
\noindent Naturalmente ogni struttura avrà metodi per facilitarne il workflow. Abbiamo un insieme di metodi condivisi fra List e Queue, mentre per Set sono sufficienti quelli ereditati da Collection.
\begin{lstlisting}[language=Java]
	// Metodi per List e Queue
	E get (int i);	// Ottieni l'elemento a posizione i
	E set(int i, E e);	// Rimpiazza l'elemento e a posizione i
	void set(int i, E e);	// Aggiungi elemento e a posizione i
	E remove(int i);	// Rimuovi elemento a posizione i
	int indexOf(E e);	// Ritorna la posizione dell'elemento e
	List<E> subList(int l, int r);	// Ritorna lista fra gli indici [l,r)
\end{lstlisting}
\noindent Un'utile implementazione di Set si ha con la sua sottoclasse \textbf{HashSet}, la quale consente l'accesso agli elementi della struttura a tempo costante in base a una determinata chiave. Questa struttura dati mantiene ineternalmente una HashMap, la quale garantisce l'unicità degli elementi usando il loro \textbf{hashcode} come chiave.\par
Per una corretta generazione del codice si deve usare il metodo \textbf{hash(obj1, obj2)}, dato dalla classe Object, per poi fare override di equals() con lo scopo di basarlo sulla chiave. Un'altra implementazione utile di Set è \textbf{TreeSet}, basata sulla logica degli RB-Alberi. Aggiunge i metodi first() e last() per prendere il nodo radice e l'ultimo del cammino rispettivamente.\newline

\noindent Un'ultima struttura sempre facente parte del JCF ma non ereditante Collection è la \textbf{Map<K, V>}, dove K sta per key e V per value. Si tratta di un insieme di associazioni che collegano una specifica chiave ad un determinato valore. Capirai che Set e Map sono strettamente legati. Presenta i seguenti metodi:
\begin{lstlisting}[language=Java]
	V put(K key, V values);	// Inserisci associamento
	V get(Object key);	// Torna il valore associato alla chiave
	V remove(Object key);	// Rimuovi l'associamento della chiave
	boolean containsKey(Object key);	// Vedi se la mappa ha una chiave
	boolean containsValue(Object value);	// Torna se valore in mappa
	Set<K> keySet();	// Ritorna le chiavi della mappa
	Collection<V> values();	// Ritorna i valori nella mappa
\end{lstlisting}
\noindent La JCF rende il il codice estremamente standardizzato; tuttavia non basta creare gli oggetti, bisogna anche poterci lavorare.\par
Le mansioni principali sono quelle di scorrere gli elementi e il loro ordinamento; questo lavoro è reso semplice grazie alla sinergia con le interfacce Iterable e Comparable e di conseguenza anche con Iterator e Comparator.

\subsection{Interfacce funzionali primitive}
Le interfacce funzionali sono un argomento già menzionato nei capitoli precedenti, tuttavia è possibile usufruire delle loro versioni base e di uso comune definite in questo pacchetto, date da:\newline

\noindent \textbf{- Predicate}\par
\noindent Prende un parametro di tipo T e ritorna un boolean. Viene spesso usato per filtrare elementi in una collection.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Predicate<T> {
		boolean test(T t);	// Qui T e' generics, ma puo' essere specificato
	}
	
	// Versione semplice
	Predicate<Integer> isEven = new Predicate<>() {
		@Override
		public boolean test(Integer n) { return n%2 == 0; }
	}
	
	// Versione lambda
	Predicate<Integer> isEven = n -> n%2 == 0;
	
	System.out.println(isEven.test(2)); // true
	System.out.println(isEven.test(3)); // false
\end{lstlisting}
\noindent \textbf{- Function}\par
\noindent Prende un parametro di tipo T e ritorna un risultato di tipo R. Spesso usato per mappare un valore ad un altro.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Function<T, R> {
		R apply(T t);
	}
	
	// Function strLen prende String e ritorna Integer
	Function<String, Integer> strLen = str -> str.length();
	
	Systm.out.println(strLen.apply("Hello"));	// Qua stampa 5
\end{lstlisting}
\noindent \textbf{- BiPredicate}\par
\noindent Prende due parametri di tipi T e U per ritornare un boolean
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface BiPredicate<T, U> {
		boolean test(T t, U u);
	}
	
	// La lambda isGreaterThan prende i due parametri e ritorna se la condizione e' vera
	BiPredicate<Integer, Integer> isGreaterThan = (a,b) -> a > b
	
	System.out.println(isGreaterThan.test(2, 5)); // false
	System.out.println(isGreaterThan.test(3, 1)); // true
\end{lstlisting}
\noindent \textbf{- BiFunction}\par
\noindent Prende due parametri di tipi T, U e ritorna un risultato di tipo R, spesso usata per implementare operazioni su due valori.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface BiFunction<T, U, R> {
		R apply(T t, U u);
	}
	
	BiFunction<Integer, Integer, Integer> sumInt = (a,b) -> a+b;
	
	System.out.println(sumInt.apply(3,9));	// Stampa 12
\end{lstlisting}
\noindent \textbf{- Consumer}\par
\noindent Prende un parametro di tipo T e non ritorna niente. Spesso usata per modellare effetti collaterali.
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Consumer<T> {
		void accept(T t);
	}
	
	// La lambda ha un effetto sull'argomento, ma non ritorna nulla
	Consumer<String> printUC = str -> System.out.println(str.toUpperCase());
	
	printUC.accept("string");	// Stampa STRING
\end{lstlisting}
\noindent \textbf{- Supplier}\par
\noindent Funzione che non prende parametri ma ritorna un valore di tipo T; spesso usata per la generazione di valori
\begin{lstlisting}[language=Java]
	@FunctionalInterface
	public interface Supplier<T> {
		T get();
	}
	
	Supplier<Double> randomNum = () -> Math.random();
	System.out.println(randomNum.get());		// Stampa il numero casuale
\end{lstlisting}
\noindent Ulteriori interfacce funzionali sono date da: \begin{center}
	\textbf{UnaryOperator<T>} extends Function<T, T>, \textbf{BinaryOperator<T>} extends BiFunction<T, T, T>
\end{center}
\noindent Dove la prima prende un parametro T per ritornarne un altro, mentre la seconda ne prende due di tipo T per ritornarne un terzo. Esiste infine una sintassi compatta per fare method reference:
\begin{lstlisting}[language=Java]
	// Sintassi compatta
	System.out::println
	// Equivale a
	str -> System.out.println(str)
\end{lstlisting}
\noindent Generalmente, valgono queste regole:
\begin{itemize}
	\item Per metodi statici: Class::staticMethod
	\item Per metodi d'istanza: object::instanceMethod
	\item Per metodi non statici: Class::nonStaticMethod
	\item Per il costruttore: Class::new
\end{itemize}	

\subsection{.Stream}


\begin{comment}
	content...
\end{comment}

%

\section{java.io.*}
Il pacchetto java.io.* fornisce funzioni relative alla gestione di un flusso di dati, sia in input, che in output.

\begin{comment}
	\subsection{.Closeable}
	\subsection{.Reader, .FileReader, .BufferedReader}
	\subsection{.Writer, .FileWriter, .BufferedWriter, .PrintWriter}
\end{comment}